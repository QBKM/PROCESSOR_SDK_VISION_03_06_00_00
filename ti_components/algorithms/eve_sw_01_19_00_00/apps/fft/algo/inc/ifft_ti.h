/*
*
* Copyright (c) 2009-2017 Texas Instruments Incorporated
*
* All rights reserved not granted herein.
*
* Limited License.
*
* Texas Instruments Incorporated grants a world-wide, royalty-free, non-exclusive
* license under copyrights and patents it now or hereafter owns or controls to make,
* have made, use, import, offer to sell and sell ("Utilize") this software subject to the
* terms herein.  With respect to the foregoing patent license, such license is granted
* solely to the extent that any such patent is necessary to Utilize the software alone.
* The patent license shall not apply to any combinations which include this software,
* other than combinations with devices manufactured by or for TI ("TI Devices").
* No hardware patent is licensed hereunder.
*
* Redistributions must preserve existing copyright notices and reproduce this license
* (including the above copyright notice and the disclaimer and (if applicable) source
* code license limitations below) in the documentation and/or other materials provided
* with the distribution
*
* Redistribution and use in binary form, without modification, are permitted provided
* that the following conditions are met:
*
* *       No reverse engineering, decompilation, or disassembly of this software is
* permitted with respect to any software provided in binary form.
*
* *       any redistribution and use are licensed by TI for use only with TI Devices.
*
* *       Nothing shall obligate TI to provide you with source code for the software
* licensed and provided to you in object code.
*
* If software source code is provided to you, modification and redistribution of the
* source code are permitted provided that the following conditions are met:
*
* *       any redistribution and use of the source code, including any resulting derivative
* works, are licensed by TI for use only with TI Devices.
*
* *       any redistribution and use of any object code compiled from the source code
* and any resulting derivative works, are licensed by TI for use only with TI Devices.
*
* Neither the name of Texas Instruments Incorporated nor the names of its suppliers
*
* may be used to endorse or promote products derived from this software without
* specific prior written permission.
*
* DISCLAIMER.
*
* THIS SOFTWARE IS PROVIDED BY TI AND TI'S LICENSORS "AS IS" AND ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL TI AND TI'S LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/


/**
 *  @file       ifft_ti.h
 *
 *  @brief      This file defines the ivision interface for FFT
 *               applet.
 *  @version 0.0 (Aug 2016) : Base version.
 */

/** @ingroup    ti_ivision_FFT */
/*@{*/
#ifndef IFFT_TI_H_
#define IFFT_TI_H_

#include <ivision.h>
#include <ti/xdais/ires.h>


/**
 * @brief The unique const funtion table for the FFT_TI.
 */
extern const IVISION_Fxns FFT_TI_VISION_FXNS;

/**
* @brief IRES interface of the FFT_TI_ algorithm
*/
extern const IRES_Fxns FFT_TI_IRES;


#define FFT_TI_MAX_NUM_STAGES (5U)
#define FFT_TI_MAX_NUM_CHUNKS (8U)

/**
  @brief Following enums describes the error codes generated by this applet

  FFT_TI_ERRORTYPE_UNSUPPORTED_FFT_DIMENSION: FFT is supported only for pre-defined
  number of points described in FFT_TI_NumPoints. Any other type will return error.

  FFT_TI_ERRORTYPE_UNSUPPORTED_IRREGULARITYFREQUENCY : The freqency of irregularity should
  not be in such a way that jump from the base pointer to the next pointer where irregularity occurs
  is more than maxumum pitch supported by DMA

  FFT_TI_ERRORTYPE_HORZ_FFT_DOPPLER_CORR_NOTSUPPORTED : For horizontal direction FFT doppler
  correction is not supported

  FFT_TI_ERRORTYPE_HORZ_FFT_NUM_CHUNK_INVALID : Horizontal direction FFT only supports numChunk
  equal to 1.

  FFT_TI_ERRORTYPE_VERT_FFT_DCOFFSET_NOTSUPPORTED : For vertical direction FFT DC offset
  cacluation and application is not supported

  FFT_TI_ERRORTYPE_VERT_FFT_SIGN_EXTENSION_NOTSUPPORTED : For vertical direction FFT sign
  extension is not supported

  FFT_TI_ERRORTYPE_VERT_FFT_INTERFERENCE_ZEROOUT_NOTSUPPORTED: For vertical direction FFT
  interference zero out is not supported

  FFT_TI_ERRORTYPE_VERT_FFT_UNSUPPORTED_PITCH: Vertical direction FFT only supports a
  maximum pitch of 32767 bytes

  FFT_TI_ERRORTYPE_VERT_FFT_UNSUPPORTED_OFFSET_BW_ANTENNAS: Vertical direction FFT offset
  between anetnnas should be same as number of points in chunk times size of each element.

  FFT_TI_ERRORTYPE_VERT_FFT_UNSUPPORTED_FFT_DIMENSION : Vertical direction FFT some of the
  higher dimension FFT is not supported

  FFT_TI_ERRORTYPE_VERT_FFT_UNSUPPORTED_IRREGULARITYFREQUENCY: Vertical direction FFT should
  not  have irregular offsetbetween antenna

  FFT_TI_ERRORTYPE_VERT_FFT_INVALID_OUTPUT_PITCH : Unsupported output pitch for the vertical FFT

  FFT_TI_ERRORTYPE_INVALID_DATABITS: Unsupported FFT_TI_CreateParams->inDataValidBits field

  FFT_TI_ERRORTYPE_FFT_UNSUPPORTED_FFT_DIRECTION : Unsupported FFT direction

  FFT_TI_ERRORTYPE_UNSUPPORTED_ZERO_PADDING : Indicates unsupported zero padding amount. Number of
  points for zero padding + number of actual points should be power of 2 and should lie between FFT_TI_NUM_POINTS_64
  and FFT_TI_NUM_POINTS_1024. Also number of points for zero padding should be multiple of VCOP_SIMD_WIDTH(8)

  FFT_TI_BUFDESC_IN_TOTAL :
  Total number of input buffers.
*/
typedef enum
{
  FFT_TI_ERRORTYPE_UNSUPPORTED_FFT_DIMENSION = IALG_CUSTOMFAILBASE,
  FFT_TI_ERRORTYPE_UNSUPPORTED_CONFIGURATION,
  FFT_TI_ERRORTYPE_UNSUPPORTED_IRREGULARITYFREQUENCY,
  FFT_TI_ERRORTYPE_HORZ_FFT_NUM_CHUNK_INVALID,
  FFT_TI_ERRORTYPE_HORZ_FFT_DOPPLER_CORR_NOTSUPPORTED,
  FFT_TI_ERRORTYPE_VERT_FFT_DCOFFSET_NOTSUPPORTED,
  FFT_TI_ERRORTYPE_VERT_FFT_SIGN_EXTENSION_NOTSUPPORTED,
  FFT_TI_ERRORTYPE_VERT_FFT_INTERFERENCE_ZEROOUT_NOTSUPPORTED,
  FFT_TI_ERRORTYPE_VERT_FFT_UNSUPPORTED_PITCH,
  FFT_TI_ERRORTYPE_VERT_FFT_UNSUPPORTED_OFFSET_BW_ANTENNAS,
  FFT_TI_ERRORTYPE_VERT_FFT_UNSUPPORTED_FFT_DIMENSION,
  FFT_TI_ERRORTYPE_VERT_FFT_UNSUPPORTED_IRREGULARITYFREQUENCY,
  FFT_TI_ERRORTYPE_VERT_FFT_INVALID_OUTPUT_PITCH,
  FFT_TI_ERRORTYPE_INVALID_DATABITS,
  FFT_TI_ERRORTYPE_FFT_UNSUPPORTED_FFT_DIRECTION,
  FFT_TI_ERRORTYPE_UNSUPPORTED_ZERO_PADDING,
  FFT_TI_ERRORTYPE_MAX_ERROR_CODE
} FFT_TI_ErrorType;


/**
  @brief User provides most of the information through buffer descriptor
         during process call. Below enums define the purpose of buffer. For optimal
         performance all the buffers should be aligned to the DDR burst size.

  FFT_TI_BUFDESC_IN_LISTBUFFER: This buffer descriptor provides the
  pointer to a buffer whose FFT needs to be calculated. This buffer is described
  using the structure define below. Kindly refer FFT_TI_BufferDescriptor to
  It is important to note that apart from the only following enteries from this structure are used by
  this applet :
  bufDesc[]->bufPlanes[].buf
  bufDesc[]->bufPlanes[].accessMask

  FFT_TI_BUFDESC_IN_WINDOWING_COEFF_BUF: This buffer descriptor provides the
  pointer to a buffer which holds the windowing coefficients used at windowing stage. The windowing
  coefficients are 16-bit signed real numbers with the size of array being equal to
  the dimension in the direction of FFT.  This buffer is   only required if windowing is enable
  by setting FFT_TI_InArgs-> enableWindowing to 1. This buffer is of dimension [RANGE_DIM] when
  FFT direction is horizontal and of dimension [DOPPLER_DIM] when FFT direction is vertical.
  It is important to note that apart from the only following enteries from this structure are used by
  this applet :
  bufDesc[]->bufPlanes[].buf
  bufDesc[]->bufPlanes[].accessMask

  FFT_TI_BUFDESC_IN_DOPPLER_CORRECTION_BUF: This buffer descriptor provides the
  pointer to a buffer which holds doppler correction array. Each  entry of this buffer is a complex  number
  with 16-bit signed real and imaginary parts interleaved. This buffer is only required if doppler correction
  is enable by setting FFT_TI_InArgs-> enableDopplerCorrection to 1. Doppler correction is only done
  when FFT direction is vertical. Dimension of this buffer should be  [NUM_ANTENNAS][DOPPLER_DIM].
  It is important to note that apart from the only following enteries from this structure are used by
  this applet :
  bufDesc[]->bufPlanes[].buf
  bufDesc[]->bufPlanes[].accessMask

  FFT_TI_BUFDESC_IN_TOTAL :
  Total number of input buffers.
*/

typedef enum
{
  FFT_TI_BUFDESC_IN_LISTBUFFER = 0,
  FFT_TI_BUFDESC_IN_WINDOWING_COEFF_BUF = 1,
  FFT_TI_BUFDESC_IN_DOPPLER_CORRECTION_BUF = 2,
  FFT_TI_BUFDESC_IN_TOTAL       = 3
} FFT_TI_InBufOrder ;


/**
  @brief User provides most of the information through buffer descriptor
         during process call. Below enums define the purpose of out buffer. For optimal
         performance all the buffers should be aligned to the DDR burst size.

  FFT_TI_BUFDESC_OUT_BUFFER:This buffer descriptor provides the
  output buffer to store the data after FFT processing. This buffer is described
  using the structure define below. Kindly refer FFT_TI_BufferDescriptor in outArgs to
  know the description of this buffer.
  It is important to note that apart from the only following enteries from this structure are used by
  this applet :
  bufDesc[]->bufPlanes[].buf
  bufDesc[]->bufPlanes[].accessMask
  bufDesc[]->bufPlanes[].width : This field indicates the pitch in bytes of the output buffer. This field is
  used only when FFT direction is FFT_TI_DIRECTION_VERTICAL. if the value for this is set to zero then
  the pitch will be calculated internally. For this case size of this buffer should be same as size of input
  buffer.
  If user wants to control the pitch of output buffer then user should first call the Control call to figure
  out the minimum pitch required and user is expected to give pitch which is greater or equal to the minimum
  pitch. The maximum supported pitch is 32767.

  FFT_TI_BUFDESC_OUT_TOTAL :
  Total number of output buffers.
*/

typedef enum
{
  FFT_TI_BUFDESC_OUT_BUFFER = 0,
  FFT_TI_BUFDESC_OUT_TOTAL  = 1
} FFT_TI_OutBufOrder ;

/**
  @brief Control command can be used to get/set some of the parameters for this
            applet. User should call the ivision->algControl call with following command ID. This is
            an optional call.
            Below enums define the control commands supported for this applet

  FFT_TI_CONTROL_GET_OUTPUT_BUFDESCRIPTOR:
    This control command can be used to get the dimension of the output buffer. User should provide FFT_TI_InArgs
     as inParams and FFT_TI_BufferDescriptor as outParams while using this control command using ivision->algControl
    command API. This control command should be called to know the memory required for output buffer along with
    the pitch for the output buffer */

typedef enum
{
  FFT_TI_CONTROL_GET_OUTPUT_BUFDESCRIPTOR
} FFT_TI_ControlCommand ;


/**
  @brief The directions in which FFT can be calculated. Below enums define for this

  FFT_TI_DIRECTION_HORIZONTAL: FFT is calculated along the direction of 1st dimension (horizontal) of buffer

  FFT_TI_DIRECTION_VERTICAL: FFT is calculated along the direction of 2nd dimension (vertical) of buffer
*/
typedef enum
{
  FFT_TI_DIRECTION_HORIZONTAL,
  FFT_TI_DIRECTION_VERTICAL
} FFT_TI_Direction ;

/**
  @brief The number of point in the direction of FFT. Below enums define for this

  FFT_TI_NUM_POINTS_1024:  Number of point of along the direction of FFT is 1024

  FFT_TI_NUM_POINTS_512:  Number of point of along the direction of FFT is 512

  FFT_TI_NUM_POINTS_256 : Number of point along the direction of FFT is 256

  FFT_TI_NUM_POINTS_128 : Number of point along the direction of FFT is 128

  FFT_TI_NUM_POINTS_64 : Number of point along the direction of FFT is 64

*/
typedef enum
{
  FFT_TI_NUM_POINTS_1024 = 1024,
  FFT_TI_NUM_POINTS_512 = 512,
  FFT_TI_NUM_POINTS_256 = 256,
  FFT_TI_NUM_POINTS_128 = 128,
  FFT_TI_NUM_POINTS_64 = 64
} FFT_TI_NumPoints ;

/**
  @brief Format of the input or output datatype. Below enums define for this

  FFT_TI_CONTAINER_FORMAT_16BIT: Each point of FFT (real and imaginary) is stored in
                                                    16 bit container
  FFT_TI_CONTAINER_FORMAT_32BIT: Each point of FFT (real and imaginary) is stored in
                                                  32 bit container
*/
typedef enum
{
  FFT_TI_CONTAINER_FORMAT_16BIT= 0,
  FFT_TI_CONTAINER_FORMAT_32BIT= 1
} FFT_TI_ContainerFormat;

/**
  @struct FFT_TI_BufferDescriptor
  @brief  This structure is used to describe the buffers (input/output) to this applet.
            This descriptor represents the buffer in the unit of Antenna. We assume the same format
            across the antenna. Kindly refer section Appendix D in EVE_Applets_UserGuide.pdf to see few
            examples for the usage of this structure

@param numChunks
            If data for a single antenna cannot be represented within a maximum supported pitch then we
            will have to split the buffer into smaller chunk such that each chunk
            can represent the data of single antenna within with a pitch. This field represents this
            number of such chunks. For a regular FFT case this field should be set to 1.
            Note : It is important to note that when the direction of FFT is  FFT_TI_DIRECTION_VERTICAL
            then the maximum supported pitch is 32767. There is no restriction on the pitch of input buffer
            when direction of FFT is FFT_TI_DIRECTION_HORIZONTAL. When direction of FFT is
            FFT_TI_DIRECTION_HORIZONTAL then numChunk should be set to 1. User can call the process call
            multiple times if there are more than one chunk when FFT direction is FFT_TI_DIRECTION_HORIZONTAL.

@param  numHorzPoints
             Number of contigous points in Horizontal direction corresponding to a single antenna. This
             is an array of size equal to numChunks field in this structure. Horizontal direction FFT
             will be calculated along this dimension. For regular FFT case this will correspond to
             the horizontal dimension of FFT

@param numVertPoints
            Number of contigous points in vertical direction corresponding to a single antenna.
            The contiguity is defined in terms of  the pitch field in this structure. Vertical direction
            FFT will be calculated along this dimension. For regulator FFT case this will correspond to
             the vertical dimension of FFT

@param offsetBwAntennas
            Offset in terms of number of bytes to jump to next antenna data from the current base pointer.
            This field is also an array having numChunks enteries. This should be word aligned

@param offsetBwAntennas1
            This field should be used only when there is an irregularity in the offsetBwAntennas. This offset is
            in terms of number of bytes to jump to next antenna data from the current antenna data pointer base
            at the point when there is irregularity. This field is only used if irregularityFrequency != 0.
            This field is also an array having numChunks enteries. This should be word aligned

@param irregularityFrequency
              This field is to indicate after how many antenna there is a irregularity in offsetBwAntennas.
              A value of zero will assume a regular case where all the offset between antennas
              are the same.
              For example if the data is arranged as shown bellow
              A0xxxxA1xxxxA2xxxxyyyy
              A3xxxxA4xxxxA5xxxxyyyy

              Here Ak represents antenna data for a particular antenna and it will have range number of samples
              in it. For the above example following would be the values of above parameters
              irregularityFrequency = 2,
              offsetBwAntennas  = xxxx
              offsetBwAntennas1 = A2 + xxxx + yyyy

@param pitch
            Offset in terms of number of bytes to jump to the next doppler index corresponding to the same
            antenna. This field is also an array having numChunks enteries. Pitch should be word algined

@param  numAntennas
              This field is meant for radar processing usecase and should be set to one
              for normal FFT calculation. This tells the total number of anetnna data which
              is coming with the buffer.


*/
typedef struct
{
  uint8_t        numChunks;
  uint16_t       numHorzPoints[FFT_TI_MAX_NUM_CHUNKS];
  uint32_t       numVertPoints;
  uint32_t       offsetBwAntennas[FFT_TI_MAX_NUM_CHUNKS];
  uint32_t       offsetBwAntennas1[FFT_TI_MAX_NUM_CHUNKS];
  uint16_t       irregularityFrequency;
  uint32_t       pitch[FFT_TI_MAX_NUM_CHUNKS];
  uint16_t       numAntennas;
} FFT_TI_BufferDescriptor;


/**
  @struct FFT_TI_CreateParams
  @brief  This structure contains all the parameters needed
              at create time for this applet

@param  fftDirection
              The direction in which FFT should be calculated. For supported values
              refer FFT_TI_Direction enum

@param inputContainerFormat
              This field is to indicate the container format of input data type. For supported
              values refer FFT_TI_ContainerFormat enum

@param outputContainerFormat
              This field is to indicate the container format of output data type. For supported
              values refer FFT_TI_ContainerFormat enum

*/
typedef struct
{
  IVISION_Params visionParams;
  uint8_t       fftDirection;
  uint8_t       inputContainerFormat;
  uint8_t       outputContainerFormat;
} FFT_TI_CreateParams;


/**
  @struct FFT_TI_InArgs
  @brief  This structure contains all the parameters which are given as an
          input to FFT applet at frame level

  @param  iVisionInArgs
                Common InArgs  for all ivision based modules

@param  bufDescription
            The input buffers to this applet comes as part of input buf
            descriptors, but the arrange of data in these buffer is described using FFT_TI_BufferDescriptor
            structure. This field hold this structure which describes the input buffers.

@param  enable32bitsIntermResults
            Set it to 1 to enable mode in which intermediary results are computed using 32-bits precision instead of 16-bits precision.
            Final outputs remain in 16-bits if outputContainerFormat was set to FFT_TI_CONTAINER_FORMAT_16BIT at creation time.
            Scaling is only applied in the last stage when results are written in 16-bits. Any scaling factor specified at other stages is automatically moved to the last stage by the applet.
            Note that this option is only applicable when outputContainerFormat is FFT_TI_CONTAINER_FORMAT_16BIT. When outputContainerFormat is FFT_TI_CONTAINER_FORMAT_32BIT,
            intermediary results are always computed in 32 bits.

  @param  enableDcOffset
              Set it to 1 to enable DC offset calculation else set it to zero. DC offset will find the average
              in both real and imaginary direction and substract it from each input sample.

  @param  enableInterferenceZeroOut
                Set it to 1 to enable interference zero out else set it to zero. This will make any input data
                point (both real and imaginary) greater than threshold specified by interferenceZeroOutThreshold
                to zero.

  @param  enableWindowing
                Set it to 1 to enable Windowing  else set it to zero. Windowing operation will multiply
                each point by the windowing coefficients before the FFT.


  @param  enableDopplerCorrection
                Set it to 1 to enable doppler correction else set it to zero. Dopper correction will do
                a point to point complex multiplication of each sample.

  @param  enableOverFlowDetection
                Set it to 1 to enable overflow detection else set it to zero. If enabled the applet will
                return the scale factors to be applied at each stage as part of outArgs. if scale factors
                are zero for each stage then there is no overflow detected

  @param  interferenceZeroOutThreshold
                Threshold to be used for interference zero out. This is the maximum absolute value of
                the input data above which that sample would be set to zero. This is only required if
                enableInterferenceZeroOut is set to 1.

  @param windowingScaleFactor
                Scale factor to be used at windowing operation. This factor is internally used to right shift ( along
                with rounding ) the output after multiplication by windowing coefficient. Mathematically
                if x is the output and n is the scaling factor then the output would be  (x + 1 << ( n - 1)) >> n.
                This is only required if windowing is enabled by setting enableWindowing = 1

  @param dopplerCorrectionScaleFactor
                  Scale factor to be used while doing doppler correction. This factor is internally used to right shift ( along
                with rounding ) the output after multiplication by doppler correction coefficients. Mathematically
                if x is the output and n is the scaling factor then the output would be  (x + 1 << ( n - 1)) >> n.
                This is only required if windowing is enabled by setting enableDopplerCorrection = 1

 @param numPointsZeroPadding
                Number of points to be added to FFT for zero padding. numFFTPoints + numPointsZeroPadding should be
                power of 2 and should lie between FFT_TI_NUM_POINTS_64 and FFT_TI_NUM_POINTS_1024. Also numPointsZeroPadding
                should be multiple of VCOP_SIMD_WIDTH (8).

  @param numValidBits
                 Number of valid bits in input data. If numValidBits is 16 then sign extension is disabled

  @param inDataRange
              This field is to indicate range of input data within the container format specified by containerFormat
              field. This information will be used to determine the stages in which overflow detection should be
              applied. This field is only required if enableOverFlowDetection is enabled ( set to 1).

  @param reserved
                This parameter is reserved parameters and is for future use.

  @param scaleFactor
                Scale Factor to be used for each stage of FFT. This factor is internally used to right shift ( along
                with rounding ) the output after multiplication by twiddle factor (in Q15). Mathematically
                if x is the output and n is the scaling factor then the output would be  (x + 1 << ( n + 15 - 1)) >> (n + 15).
                Each stage of FFT grows by certain amount ( 1 bit or 2 bit for radix 2 or radix-4 respectively). Hence to avoid overflow
                each stage scale factor should be chosen such that input data is within 15 bit. It is important
                to note that in our implementation twiddle factors are stored in Q15 format and hence if a particular stage
                scale factos is n then its effective scaling applied at output would be (15 + n).
                Note that if enable32bitsIntermResults=1, in order to maintain the maximum dynamic range of 32-bits
                for the intermediary stages, no scaling is performed at these intermediate stages. Only when output is 16-bits, to prevent overflow in the last stage, scaling is applied.
                Note that the user can still specify scale factors for the intermediary stages. The applet will simply sum them up, add them to
                the last stage's scale factor.
*/

typedef struct
{
  IVISION_InArgs iVisionInArgs;
  FFT_TI_BufferDescriptor bufDescription;
  uint8_t                 enable32bitsIntermResults;
  uint8_t                 enableDcOffset;
  uint8_t                 enableInterferenceZeroOut;
  uint8_t                 enableWindowing;
  uint8_t                 enableDopplerCorrection;
  uint8_t                 enableOverFlowDetection;
  uint8_t                 numValidBits;
  uint8_t                 inDataRange;
  uint16_t                interferenceZeroOutThreshold;
  uint16_t                windowingScaleFactor;
  uint16_t                dopplerCorrectionScaleFactor;
  uint16_t                numPointsZeroPadding;
  uint32_t                reserved;
  uint16_t                scaleFactors[FFT_TI_MAX_NUM_STAGES];
} FFT_TI_InArgs;


/**
  @struct FFT_TI_OutArgs
  @brief  This structure contains all the parameters which are given as an
          output by FFT applet  at frame level

  @param  iVisionOutArgs
          Common outArgs for all ivison based modules

  @param  bufDescription
              The output buffers to this applet comes as part of output buf
              descriptors, but the arrange of data in these buffer is described using FFT_TI_BufferDescriptor
              structure. This field hold this structure which describes the output buffer.

  @param  scaleFactors
              This array returns the scale factors to be applied at each stage when overflow detection is
              enabled. If scaleFactors for each stage is zero then no overflow has occured

*/

typedef struct
{
  IVISION_OutArgs iVisionOutArgs;
  FFT_TI_BufferDescriptor bufDescription;
  uint16_t                scaleFactors[FFT_TI_MAX_NUM_STAGES];
} FFT_TI_OutArgs;


/*@}*/
/* ti_ivision_FFT */

#endif /*IFFT_TI_H_ */
/*==========================================================================*/
/*     END of the FILE                                                      */
/*==========================================================================*/

