/*
*
* Copyright (c) 2015-2017 Texas Instruments Incorporated
*
* All rights reserved not granted herein.
*
* Limited License.
*
* Texas Instruments Incorporated grants a world-wide, royalty-free, non-exclusive
* license under copyrights and patents it now or hereafter owns or controls to make,
* have made, use, import, offer to sell and sell ("Utilize") this software subject to the
* terms herein.  With respect to the foregoing patent license, such license is granted
* solely to the extent that any such patent is necessary to Utilize the software alone.
* The patent license shall not apply to any combinations which include this software,
* other than combinations with devices manufactured by or for TI ("TI Devices").
* No hardware patent is licensed hereunder.
*
* Redistributions must preserve existing copyright notices and reproduce this license
* (including the above copyright notice and the disclaimer and (if applicable) source
* code license limitations below) in the documentation and/or other materials provided
* with the distribution
*
* Redistribution and use in binary form, without modification, are permitted provided
* that the following conditions are met:
*
* *       No reverse engineering, decompilation, or disassembly of this software is
* permitted with respect to any software provided in binary form.
*
* *       any redistribution and use are licensed by TI for use only with TI Devices.
*
* *       Nothing shall obligate TI to provide you with source code for the software
* licensed and provided to you in object code.
*
* If software source code is provided to you, modification and redistribution of the
* source code are permitted provided that the following conditions are met:
*
* *       any redistribution and use of the source code, including any resulting derivative
* works, are licensed by TI for use only with TI Devices.
*
* *       any redistribution and use of any object code compiled from the source code
* and any resulting derivative works, are licensed by TI for use only with TI Devices.
*
* Neither the name of Texas Instruments Incorporated nor the names of its suppliers
*
* may be used to endorse or promote products derived from this software without
* specific prior written permission.
*
* DISCLAIMER.
*
* THIS SOFTWARE IS PROVIDED BY TI AND TI'S LICENSORS "AS IS" AND ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL TI AND TI'S LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/

#pragma CHECK_MISRA ("none")
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "stdint.h"
#include "xdais_types.h"
#include "iSceneObstructionDetect_ti.h"
#include "ti_mem_manager.h"
#include "profile.h"

/* Reference input data made of focus values normally generated by the TDA3s H3A engine */
uint32_t fvStats[]={855174, 181024, 21170, 4988, 214728, 28331, 4988, 0, 26853, 454, 4988, 0, 26853, 454, 4988, 0, 421863, 66616, 2663, 4988, 68806, 2940, 4988, 0, 10670, 101, 4988, 0, 10670, 101, 4988, 0, 451296, 60306, 1372, 4988, 60932, 1570, 4988, 0, 8337, 143, 4988, 0, 8337, 143, 4988, 0, 748459, 129687, 13247, 4988, 140388, 13217, 4988, 0, 18496, 145, 4988, 0, 18496, 145, 4988, 0, 631404, 165292, 19370, 4988, 158117, 16794, 4988, 0, 18529, 247, 4988, 0, 18529, 247, 4988, 0, 420773, 61970, 1717, 4988, 66673, 1745, 4988, 0, 15342, 327, 4988, 0, 15342, 327, 4988, 0, 296781, 43279, 321, 4988, 44557, 398, 4988, 0, 6683, 25, 4988, 0, 6683, 25, 4988, 0, 319287, 45123, 332, 4988, 47114, 436, 4988, 0, 7832, 13, 4988, 0, 7832, 13, 4988, 0, 412695, 46509, 387, 4988, 44975, 330, 4988, 0, 6460, 0, 4988, 0, 6460, 0, 4988, 0};

#if (!HOST_EMULATION)
void _TSC_enable();
long long _TSC_read();

#define L2CFG()  (*(volatile uint32_t *)0x01840000)
#define L1PCFG() (*(volatile uint32_t *)0x01840020)
#define L1DCFG() (*(volatile uint32_t *)0x01840040)

static void SetMAR()
{

    uint32_t i ;

    uint32_t* MAR = (uint32_t*)0x01848200 ; //MAR_128

    /* DDR from 0x80000000 to 9F000000 made cacheable */
    /* From 9F000000 to A0000000 is non-cacheable region. */
    /*  This non-cacheable region is used to hold input and output buffers */
    for(i = 128 ;i <= 158 ; i++)
    {
        *MAR = 0x1;
        MAR++ ;
    }
    return ;
}

static void CacheWbInv()
{
    uint32_t* L1DWBINV = (uint32_t *)0x01845044;
    uint32_t* L2WBINV = (uint32_t *)0x01845004;

    /* Write back invalidate cache */
    *L1DWBINV = 1;
    *L2WBINV = 1; 
}

static void InitCache()
{
    /*-------------------------------------------------------------------------*/
    /* 4-> full 256 KB as cache, 3-> 128KB, 2 -> 64KB, 1-> 32KB                */
    /* IMPORTANT :: Currently 0 KB of L2 is assumed to be SRAM, hence in final */
    /* application any amount L2 can be configured as SRAM, but DMVAL will not */
    /* use that. Only thing here important is that if in application full L2 is*/
    /* configured as cache then standalone and final application performance   */
    /* numbers will match. otherwise no functionality issue.                    */
    /*-------------------------------------------------------------------------*/
    L2CFG()  = 3;

    /*-------------------------------------------------------------------------*/
    /* Full L1P is configured as 32KB of cache                                 */
    /* Nothing in L1P is assumed as SRAM, so no dependency from final applicati*/
    /* -on configuration. Only thing if full L1P is configured as cache then   */
    /* standalone and application performance numbers will match.              */
    /*-------------------------------------------------------------------------*/
    L1PCFG() = 4;

    /*-------------------------------------------------------------------------*/
    /* 1 -> 4 KB, 2-> 8KB, 3 ->16 KB, 4 -> 32KB as cache                       */
    /* Currently 4KB as cache has been allocated for L1D, Rest 28 KB is configu*/
    /* red as SRAM. Any change in cache configuration should be done in conjuca*/
    /* of linker command file modification in test applciation                 */
    /* IMPORTANT :: Here 28 KB of L1 D is assumed as SRAM hence there is depend*/
    /* -dency from final applcaition configuration of L1D. If atleast 28 KB of */
    /* L1D is not configured as SRAM in final application then that will be a  */
    /* functional issue.                                                       */
    /*-------------------------------------------------------------------------*/
    L1DCFG() = 2;

    SetMAR() ;
}

#endif

#define ALIGN_T0_32(x) (((x+31)/32)*32)


#define PRINT_ERRORE_MSG()  printf("Error at line: %5d : in file %22s, of function : %s \n",__LINE__, __FILE__,__FUNCTION__)

#define DMEM_SIZE (24*1024)

#define L2SRAMMEM_SIZE (128*1024)

#define DDRNONCACHE_SIZE (16384*1024)

#pragma DATA_SECTION (DMEM_SCRATCH, ".dmemSect");
/* This will be used for allocation of memory in DMEM*/
uint8_t DMEM_SCRATCH[DMEM_SIZE];
TIMemObject memObj_DMEM;


#pragma DATA_SECTION (L2MEM_SCRATCH, ".l2memSect");
uint8_t L2MEM_SCRATCH[L2SRAMMEM_SIZE];
TIMemObject memObj_L2MEM;

#pragma DATA_SECTION (DDRMEM_NONCACHE, ".ddrnoncacheSect");
uint8_t DDRMEM_NONCACHE[DDRNONCACHE_SIZE];
TIMemObject memObj_DDRMEMNC;

int32_t TestApp_AllocMemRecords(IALG_MemRec * memRec,int32_t numMemRec)
{
    int32_t i;
    TIMemHandle memHdl_DMEM = &memObj_DMEM;
    TIMemHandle memHdl_L2MEM = &memObj_L2MEM;

    for (i = 0; i < numMemRec; i++)
    {
        if(memRec[i].space == IALG_DARAM0) {
            memRec[i].base = TI_GetMemoryChunk(memHdl_DMEM, memRec[i].size, memRec[i].alignment);
        }
        else if(memRec[i].space == IALG_DARAM1) {
            memRec[i].base = TI_GetMemoryChunk(memHdl_L2MEM, memRec[i].size, memRec[i].alignment);
        }
        else {
            memRec[i].base = (Void *) malloc( memRec[i].size);
        }
        if(memRec[i].base == NULL)
        {
            return IALG_EFAIL;
        }
    }
    return IALG_EOK;
}

int32_t TestApp_FreeMemRecords(IALG_MemRec * memRec,int32_t numMemRec)
{
    int32_t i;
    TIMemHandle memHdl_DMEM = &memObj_DMEM;
    TIMemHandle memHdl_L2MEM = &memObj_L2MEM;

    for (i = 0; i < numMemRec; i++)
    {
        if(memRec[i].base == NULL)
        {
            return IALG_EFAIL;
        }
        else if(memRec[i].space == IALG_DARAM0) {
            TI_ResetMemoryHandle(memHdl_DMEM);
        }
        else if(memRec[i].space == IALG_DARAM1) {
            TI_ResetMemoryHandle(memHdl_L2MEM);
        }
        else {
            free(memRec[i].base);
        }
    }
    return IALG_EOK;
}

typedef struct IM_Fxns
{
    IVISION_Fxns * ivision;

} IM_Fxns;


int32_t sceneObstructionDetectTest(void)
{
    int32_t numMemRec;
    uint32_t i;
    IALG_MemRec *memRec;
    int32_t status;
    FILE *fid;

    int32_t fail;
    uint32_t result;

    long long  t0, t1;

#if (!HOST_EMULATION)
    _TSC_enable();
#endif
    /*-----------------------------------------------------------------
   Pointer to algorithm instance
   -----------------------------------------------------------------*/
    IM_Fxns *     handle;

    /*-----------------------------------------------------------------
   Algorithm parameters memory in stack
   -----------------------------------------------------------------*/
    SCENE_OBSTRUCTION_DETECT_TI_CreateParams   createParams;
    SCENE_OBSTRUCTION_DETECT_TI_InArgs      inArgs;
    IVISION_InBufs    inBufs;

    /*-----------------------------------------------------------------
  For test purpose it is allocated in stack. Application may get
  this descriptors from its buffer manager
  -----------------------------------------------------------------*/
    IVISION_BufDesc   inBufDesc[SCENE_OBSTRUCTION_DETECT_TI_BUFDESC_IN_TOTAL];
    IVISION_BufDesc   *inBufDescList[SCENE_OBSTRUCTION_DETECT_TI_BUFDESC_IN_TOTAL];

    SCENE_OBSTRUCTION_DETECT_TI_OutArgs     outArgs;
    IVISION_OutBufs   outBufs;

    /*-----------------------------------------------------------------
  For test purpose it is allocated in stack. Application may get
  this descriptors from its buffer manager
  -----------------------------------------------------------------*/
    IVISION_BufDesc   outBufDesc[SCENE_OBSTRUCTION_DETECT_TI_BUFDESC_OUT_TOTAL];
    IVISION_BufDesc   *outBufDescList[SCENE_OBSTRUCTION_DETECT_TI_BUFDESC_OUT_TOTAL];

#if ENABLE_TRACES
    IVISION_BufDesc   outImBufDesc;
    IVISION_BufDesc   *outImBufDescList[1];
    IVISION_InBufs    outImBufs;
    uint8_t *laneOutIm;
    uint8_t  levelCnt=0;
#endif

    outArgs.iVisionOutArgs.size = sizeof(SCENE_OBSTRUCTION_DETECT_TI_OutArgs);
    inArgs.iVisionInArgs.size   = sizeof(SCENE_OBSTRUCTION_DETECT_TI_InArgs);

    /*--------------------------------------------------------------------------*/
    /*Create memory handle for L1DMEM.                                      */
    /*--------------------------------------------------------------------------*/
    uint8_t *pDmem;
    TIMemHandle memHdl_DMEM;

    /*--------------------------------------------------------------------------*/
    /*Create memory handle for L2MEM.                                      */
    /*--------------------------------------------------------------------------*/
    uint8_t *pL2mem;
    TIMemHandle memHdl_L2MEM;

    /*--------------------------------------------------------------------------*/
    /*Create memory handle for DDR NON CACHE MEM                     */
    /*--------------------------------------------------------------------------*/
    uint8_t *pExtmem;
    TIMemHandle memHdl_EXTMEM;

    pDmem = (uint8_t *)&DMEM_SCRATCH;
    memHdl_DMEM = &memObj_DMEM;
    TI_CreateMemoryHandle(memHdl_DMEM, pDmem, DMEM_SIZE);

    pL2mem = (uint8_t *)&L2MEM_SCRATCH;
    memHdl_L2MEM = &memObj_L2MEM;
    TI_CreateMemoryHandle(memHdl_L2MEM, pL2mem, L2SRAMMEM_SIZE);

    pExtmem = (uint8_t *)&DDRMEM_NONCACHE;
    memHdl_EXTMEM = &memObj_DDRMEMNC;
    TI_CreateMemoryHandle(memHdl_EXTMEM, pExtmem, DDRNONCACHE_SIZE);
    /*-----------------------------------------------------------------
      Set buffer descriptor pointers array base
      -----------------------------------------------------------------*/
    inBufs.bufDesc  = inBufDescList;
    outBufs.bufDesc = outBufDescList;

    inBufs.numBufs   = SCENE_OBSTRUCTION_DETECT_TI_BUFDESC_IN_TOTAL;
    outBufs.numBufs  = SCENE_OBSTRUCTION_DETECT_TI_BUFDESC_OUT_TOTAL;

    for(i = 0 ; i < SCENE_OBSTRUCTION_DETECT_TI_BUFDESC_IN_TOTAL ;i++)
    {
        inBufDescList[i]     = &inBufDesc[i];
        inBufDesc[i].numPlanes  = 1;
    }

    for(i = 0 ; i < SCENE_OBSTRUCTION_DETECT_TI_BUFDESC_OUT_TOTAL ;i++)
    {
        outBufDescList[i]     = &outBufDesc[i];
        outBufDesc[i].numPlanes  = 1;
    }

    /* Read input data from file */
    fid= fopen("../testvecs/input/H3A_AF.buff","rb");
    assert(fid!=NULL);
    fread(&fvStats[0], 1, sizeof(fvStats), fid);
    fclose(fid);
    
    /*-----------------------------------------------------------------
      Set algorithm parameters
      -----------------------------------------------------------------*/
    createParams.wdrEnable   = 0;
    createParams.paxNumH     = 3;
    createParams.paxNumV     = 3;
    createParams.vfEnable    = 1;
    createParams.scaleFactor = 10.0;
    createParams.classifierCoef[0]= 6.010115;
    createParams.classifierCoef[1]= 1.562322;
    createParams.classifierCoef[2]= -33.339242;
    createParams.classifierCoef[3]= 1.963373;
    createParams.classifierCoef[4]= -39.755250;
    createParams.classifierCoef[5]= 0.0;
    createParams.classifierCoef[6]= 0.0;
    createParams.classifierCoef[7]= 0.0;
    createParams.classifierCoef[8]= 0.0;
    createParams.classifierCoef[9]= 0.0;
    createParams.classifierCoef[10]= 0.0;
    createParams.sensitivity= -2.0;
    createParams.frameSkipInterval= 10;
    createParams.numBlockedFramesThreshold= 1;

    createParams.edma3RmLldHandle   = NULL;

    /*-----------------------------------------------------------------
      Query alogorithm memory requirement using standard IALG interface
      -----------------------------------------------------------------*/
    numMemRec = SCENE_OBSTRUCTION_DETECT_TI_VISION_FXNS.ialg.algNumAlloc();
    memRec    = (IALG_MemRec *)malloc(numMemRec*sizeof(IALG_MemRec));

    status = SCENE_OBSTRUCTION_DETECT_TI_VISION_FXNS.ialg.algAlloc((IALG_Params *)(&createParams), NULL, memRec);

    if(status != IALG_EOK)
    {
        PRINT_ERRORE_MSG();
        goto EXIT_LOOP;
    }
#if ENABLE_TRACES
    printf("Scene Obstruction Detection algorithm Create Done\n");
#endif
    /*-----------------------------------------------------------------
      Allocate memory for all the mem records
      Application has to implement the below function
      Refer the example implementation below in this file
      -----------------------------------------------------------------*/
    status = TestApp_AllocMemRecords(memRec,numMemRec);
    if(status != IALG_EOK)
    {
        PRINT_ERRORE_MSG();
        goto EXIT_LOOP;
    }

    /*-----------------------------------------------------------------
      Intialize the algorithm instance with the alocated memory
      and user create parameters
      -----------------------------------------------------------------*/
    status = SCENE_OBSTRUCTION_DETECT_TI_VISION_FXNS.ialg.algInit((IALG_Handle)(&handle),
            memRec,NULL,(IALG_Params *)(&createParams));

    handle = (IM_Fxns *) memRec[0].base;

    if(status != IALG_EOK)
    {
        PRINT_ERRORE_MSG();
        goto EXIT_LOOP;
    }
#if ENABLE_TRACES
    printf("Scene Obstruction Detection algorithm Init Done\n");
#endif

    inArgs.iVisionInArgs.subFrameInfo = 0;
    inArgs.iVisionInArgs.size         = sizeof(SCENE_OBSTRUCTION_DETECT_TI_InArgs);

#if ENABLE_TRACES
    printf("Processing started for frame \n");
#endif

    inBufs.bufDesc[SCENE_OBSTRUCTION_DETECT_TI_BUFDESC_IN_FV_STATS]->bufPlanes[0].buf= (void*)&fvStats[0];
    outBufs.bufDesc[SCENE_OBSTRUCTION_DETECT_TI_BUFDESC_OUT]->bufPlanes[0].buf = &result;

#if (!HOST_EMULATION)
    /* Write back Invalidate cache */
    CacheWbInv();
    t0 = _TSC_read();
#endif
    status = handle->ivision->algProcess((IVISION_Handle)handle,
            &inBufs,&outBufs,(IVISION_InArgs *)&inArgs,(IVISION_OutArgs *)&outArgs);

#if (!HOST_EMULATION)
    t1 = _TSC_read();
    printf(" Cycles per frame %d \n", t1-t0);      
    /* Write back Invalidate cache */
    CacheWbInv();
#endif

    if(status != IALG_EOK)
    {
        PRINT_ERRORE_MSG();
        goto EXIT_LOOP;
    }
#if ENABLE_TRACES
    printf("Processing Completed\n");
#endif

    if (result== 0) {
        fail= 0;
    }
    else {
        fail= 1;
    }

    if (fail==0) {
        printf("Verification successful !!!!\n");
    }

    EXIT_LOOP:

    status = handle->ivision->ialg.algFree((IALG_Handle)(handle), memRec);
    if(status != IALG_EOK)
    {
        PRINT_ERRORE_MSG();
    }
    /* Here Free memory for all the mem records */
    status = TestApp_FreeMemRecords(memRec,numMemRec);
    if(status != IALG_EOK)
    {
        PRINT_ERRORE_MSG();
    }

    if ( memRec != NULL )
    {
        free(memRec);
    }

    return status;
}

int32_t main(int32_t argc, char *argv[])
{
    int32_t status = 0;

#if (!HOST_EMULATION)
    InitCache();
#endif

    /* Validate the algorithm */
    status = sceneObstructionDetectTest();

    return status;
}



