<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" />
<title>PDK/PDK VPS Capture Driver User Guide - Texas Instruments Wiki</title>
<meta name="generator" content="MediaWiki 1.25.1" />
<link rel="shortcut icon" href="favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://processors.wiki.ti.com/api.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="PDK_VPS_Capture_Driver_User_Guide.html" />
<link rel="copyright" href="http://creativecommons.org/licenses/by-sa/3.0/" />
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="http://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="load.php@debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%252Cshared%257Cmediawiki.sectionAnchor%257Cmediawiki.skinning.interface%257Cmediawiki.ui.button%257Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;%252A.css" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="load.php@debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;%252A.css" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: davincid_wikidb:resourceloader:filter:minify-css:7:70500b672b667d946e900b286b62c126 */</style>
<script src="load.php@debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;%252A"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"PDK/PDK_VPS_Capture_Driver_User_Guide","wgTitle":"PDK/PDK VPS Capture Driver User Guide","wgCurRevisionId":229115,"wgRevisionId":229115,"wgArticleId":45039,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Software \u0026 Tools"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"PDK/PDK_VPS_Capture_Driver_User_Guide","wgRelevantArticleId":45039,"wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"publish":false},"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":false,\"namespaces\":false}"});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});
/* cache key: davincid_wikidb:resourceloader:filter:minify-js:7:a5c52c063dc436c1ca7c9f456936a5e9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/Vector/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-PDK_PDK_VPS_Capture_Driver_User_Guide skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

							<div id="siteNotice"><div id="localNotice" lang="en" dir="ltr"><p><br />
<span style="color:#ff0000"><b>Please note as of Wednesday, August 15th, 2018 this wiki has been set to read only. If you are a TI Employee and require Edit ability please contact x0211426 from the company directory.</b></span>
</p></div></div>
						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">PDK/PDK VPS Capture Driver User Guide</span></h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From Texas Instruments Wiki</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="PDK_VPS_Capture_Driver_User_Guide.html#mw-head">navigation</a>, 					<a href="PDK_VPS_Capture_Driver_User_Guide.html#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="hf-nsheader"><script language = "Javascript">
var tiContentGroup;
var tiwikicat = (typeof(mw.config.values.wgCategories[0]) === "undefined"? "":mw.config.values.wgCategories[0]);
tiContentGroup = "/DSP/wiki/Ext/" +tiwikicat;
var tiPageName;
tiPageName = 'wiki/PDK/PDK_VPS_Capture_Driver_User_Guide';
</script></div><div class="hf-header"></div><div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Introduction"><span class="tocnumber">1</span> <span class="toctext"><b>Introduction</b></span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Features_supported"><span class="tocnumber">1.1</span> <span class="toctext"><b>Features supported</b></span></a></li>
<li class="toclevel-2 tocsection-3"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Input_to_Output_Combinations_support"><span class="tocnumber">1.2</span> <span class="toctext">Input to Output Combinations support</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Limitations.2FIssues"><span class="tocnumber">1.3</span> <span class="toctext"><b>Limitations/Issues</b></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Software_Application_Interfaces"><span class="tocnumber">2</span> <span class="toctext"><b>Software Application Interfaces</b></span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="PDK_VPS_Capture_Driver_User_Guide.html#System_Init_Phase"><span class="tocnumber">2.1</span> <span class="toctext"><b>System Init Phase</b></span></a></li>
<li class="toclevel-2 tocsection-7"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Create_Phase"><span class="tocnumber">2.2</span> <span class="toctext"><b>Create Phase</b></span></a></li>
<li class="toclevel-2 tocsection-8"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Control_Phase"><span class="tocnumber">2.3</span> <span class="toctext"><b>Control Phase</b></span></a>
<ul>
<li class="toclevel-3 tocsection-9"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Driver_Instance_to_hardware_port_mapping_for_different_bus-widths"><span class="tocnumber">2.3.1</span> <span class="toctext"><b>Driver Instance to hardware port mapping</b> for different bus-widths</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Output_streams"><span class="tocnumber">2.3.2</span> <span class="toctext"><b>Output streams</b></span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-11"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Run_Phase"><span class="tocnumber">2.4</span> <span class="toctext"><b>Run Phase</b></span></a>
<ul>
<li class="toclevel-3 tocsection-12"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Start_and_stop"><span class="tocnumber">2.4.1</span> <span class="toctext"><b>Start and stop</b></span></a></li>
<li class="toclevel-3 tocsection-13"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Dequeueing-Queuing_frames"><span class="tocnumber">2.4.2</span> <span class="toctext"><b>Dequeueing-Queuing frames</b></span></a></li>
<li class="toclevel-3 tocsection-14"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Callback"><span class="tocnumber">2.4.3</span> <span class="toctext"><b>Callback</b></span></a></li>
<li class="toclevel-3 tocsection-15"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Understanding_captured_frame_information"><span class="tocnumber">2.4.4</span> <span class="toctext"><b>Understanding captured frame information</b></span></a></li>
<li class="toclevel-3 tocsection-16"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Buffer_Capture_Mode_.28BCM.29"><span class="tocnumber">2.4.5</span> <span class="toctext"><b>Buffer Capture Mode (BCM)</b></span></a></li>
<li class="toclevel-3 tocsection-17"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Control_IOCTLs_supported"><span class="tocnumber">2.4.6</span> <span class="toctext"><b>Control IOCTLs supported</b></span></a>
<ul>
<li class="toclevel-4 tocsection-18"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Frame_skip_control_IOCTL_VPS_CAPT_SET_FRAME_SKIP"><span class="tocnumber">2.4.6.1</span> <span class="toctext"><b>Frame skip control IOCTL_VPS_CAPT_SET_FRAME_SKIP</b></span></a></li>
<li class="toclevel-4 tocsection-19"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Get_Channel_Status_IOCTL_VPS_CAPT_GET_CH_STATUS"><span class="tocnumber">2.4.6.2</span> <span class="toctext"><b>Get Channel Status IOCTL_VPS_CAPT_GET_CH_STATUS</b></span></a></li>
<li class="toclevel-4 tocsection-20"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Max_Size_IOCTL_VPS_CAPT_SET_VIP_MAX_SIZE"><span class="tocnumber">2.4.6.3</span> <span class="toctext"><b>Max Size IOCTL_VPS_CAPT_SET_VIP_MAX_SIZE</b></span></a></li>
<li class="toclevel-4 tocsection-21"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Set_VIP_Parameters_IOCTL_VPS_CAPT_SET_VIP_PARAMS"><span class="tocnumber">2.4.6.4</span> <span class="toctext"><b>Set VIP Parameters IOCTL_VPS_CAPT_SET_VIP_PARAMS</b></span></a></li>
<li class="toclevel-4 tocsection-22"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Get_VIP_Parameters_IOCTL_VPS_CAPT_GET_VIP_PARAMS"><span class="tocnumber">2.4.6.5</span> <span class="toctext"><b>Get VIP Parameters IOCTL_VPS_CAPT_GET_VIP_PARAMS</b></span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-23"><a href="PDK_VPS_Capture_Driver_User_Guide.html#Delete_Phase"><span class="tocnumber">2.5</span> <span class="toctext"><b>Delete Phase</b></span></a></li>
<li class="toclevel-2 tocsection-24"><a href="PDK_VPS_Capture_Driver_User_Guide.html#System_De-init_Phase"><span class="tocnumber">2.6</span> <span class="toctext"><b>System De-init Phase</b></span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Introduction"><b>Introduction</b></span></h1>
<p>VIP capture driver makes use of VIP hardware block in Tda2xx to capture data from external video source like video decoders (example, TVP5158, SIL9127) or sensors (example OV1063X). The video data is captured from the external video source by the VIP Parser sub-block in the VIP block. The VIP Parser then sends the captured data for further processing in the VIP block which can include colour space conversion, scaling, chroma down sampling and finally writes the video data to external DDR memory or an OCMC buffer. 
</p><p>The data paths supported by the current driver implementation are shown in the below figure: 
</p>
<div style="padding: 5px; background: none repeat scroll 0% 0% rgb(238, 238, 238); color: rgb(52, 128, 23);"><b>Important</b><br /> The 422 secondary path and HDCOMP (RGB) path as shown in the figure below are wired out for Tda2xx.</div> 
<br /> <div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:881px;"><a href="http://processors.wiki.ti.com/index.php/File:Vip-capture-paths.png" class="image"><img alt="" src="Vip-capture-paths.png" width="879" height="655" class="thumbimage" /></a>  <div class="thumbcaption">Vip-capture-paths.png</div></div></div></div><br /> 
<h2><span class="mw-headline" id="Features_supported"><b>Features supported</b></span></h2>
<table border="1" cellspacing="1" cellpadding="1" style="width: 963px; height: 1053px;">

<tr>
<th scope="col">
<p><br /> 
</p><p>Features 
</p>
</th>
<th scope="col"> Supported in Tda2xx<br />
</th>
<th scope="col"> Supported in TI814x<br />
</th></tr>
<tr>
<td> <b>Input Video Source Formats</b><br />
</td>
<td> <br />
</td>
<td> <br />
</td></tr>
<tr>
<td> YUV422 8-bit embedded sync mode<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> YUV422 16-bit embedded sync mode<br />
</td>
<td> NOT TESTED<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> RGB 24-bit embedded sync mode<br />
</td>
<td> NOT TESTED<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> YUV422 8-bit discrete sync mode<br />
</td>
<td> YES<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> YUV422 16-bit discrete sync mode<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> RGB 24-bit discrete sync mode<br />
</td>
<td> NOT TESTED<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> YUV422 8-bit 2x/4x pixel multiplxed mode<br />
</td>
<td> NO<br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td> YUV422 8-bit 4x line multiplexed mode<br />
</td>
<td> NO<br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td> YUV422 8-bit 4x split-line multiplexed mode<br />
</td>
<td> NO<br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td> YUV444 24-bit embedded/discrete sync mode<br />
</td>
<td> NOT TESTED<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <b>Output Video formats</b><br />
</td>
<td> <br />
</td>
<td> <br />
</td></tr>
<tr>
<td> YUV422 YUYV interleaved format<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> YUV420 Semi-planer format<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> RGB 24-bit interleaved format<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> YUV422 Semi-planer format<br />
</td>
<td> YES<br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td> <b>In-line video processing features</b><br />
</td>
<td> <br />
</td>
<td> <br />
</td></tr>
<tr>
<td> Color space conversion<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> Down-Scaling<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> Chroma-down sampling<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> <b>Other features</b><br />
</td>
<td> <br />
</td>
<td> <br />
</td></tr>
<tr>
<td> Multi-instance (VIP1, VIP2, VIP3), multi-slice (S0, S1), multi-port capture (Port A, Port B), with ability to configure each instance, port independently<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> Interlaced as well as progressive capture<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> Per frame info to user like - field ID, captured frame width x height, timestamp, logical channel ID<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> Frame-rate depends on external video source, no limitation in driver as such<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> For RGB input, optional color space conversion to YUV is supported<br />
</td>
<td> NOT TESTED<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> For RGB input with color space conversion to YUV enabled, optional scaling is supported<br />
</td>
<td> NOT TESTED<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> For YUV input, optional color space conversion to RGB is supported<br />
</td>
<td> YES<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> For YUV input, optional scaling is supported<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> For YUV input, optional chroma downsampling is supported<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> Per channel frame-dropping. Example, for a 60fps video source, 30fps, 15fps, 7fps capture<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> Ability to change scalar parameters while capture is running<br />
</td>
<td> NO<br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td> Single source (RGB 24-bit or YUV422 8/16-bit), dual output (RGB 24-bit and/or YUV422 and/or YUV420)<br />support. See table below for support combinations<br />
</td>
<td> YES<br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td> Raw VBI capture for single/multi channel modes<br />
</td>
<td> NO<br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td> Non-blocking FVID2 queue, dequeue API support<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> Possible to configure VIP port for different video input source properties like Hsync polarity, Vsync polarity, PCLK polarity <br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> Tiler memory support when output type is YUV420 semi-planer<br />
</td>
<td> NOT TESTED<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> Sub-frame based capture<br />
</td>
<td> YES<br />
</td>
<td> YES<br />
</td></tr></table>
<ul><li>In the table above,<br />Support = YES, means feature has been tested with current driver on current platform board/EVM.<br />Support = NO, means feature is not supported in current driver and using it will give unpredictable results. Feature is planned to be supported in future releases.<br />Support = NOT TESTED, means feature is present in driver but has NOT&#160;been tested on due to current platform board/EVM limitations AND/OR is planned to be tested in subsequent releases.<br /></li></ul>
<p><br />
</p>
<h2><span class="mw-headline" id="Input_to_Output_Combinations_support">Input to Output Combinations support</span></h2>
<table border="1" cellspacing="1" cellpadding="1" style="width: 970px; height: 423px">

<tr>
<th scope="col"> Input Format
</th>
<th scope="col"> Output format - 0
</th>
<th scope="col"> Output format - 1
</th>
<th scope="col"> Supoprt in Tda2xx
</th></tr>
<tr>
<td rowspan="10"> <span style="background-color: rgb(255,204,153)"><span style="background-color: rgb(255,255,255)">YUV422 8/16-bit embedded/discrete sync mode</span><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></span>
</td>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format (via CSC)</span><br />
</td>
<td> NONE<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format (via CSC)</span><br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output MUST BE scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output MUST be scaled)</span><br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> YUV422 YUYV interleaved format (one output optionally scaled)<br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output MUST be scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output MUST be scaled)</span><br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format (via CSC)</span><br />
</td>
<td> YES<br />
</td></tr>
<tr>
<td colspan="4"> <br />
</td></tr>
<tr>
<td> YUV444 24-bit embedded/discrete sync mode<br />
</td>
<td> NA<br />
</td>
<td> NA<br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td rowspan="12"> RGB 24-bit discrete sync mode (CSC is used when output format is YUV)<br /><br /><br /><br /><br />
</td>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output optionally scaled)
<p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</span>
</p>
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output MUST BE scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output MUST be scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output MUST be scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output MUST be scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td colspan="4"> <br />
</td></tr>
<tr>
<td rowspan="12"> RGB 16-bit discrete sync mode (CSC is used when output format is YUV)<br /><br /><br /><br /><br />
</td>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output optionally scaled)
<p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</span>
</p>
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output MUST BE scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output MUST be scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output MUST be scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output MUST be scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td colspan="4"> <br />
</td></tr>
<tr>
<td rowspan="12"> RGB 8-bit discrete sync mode (CSC is used when output format is YUV)<br /><br /><br /><br /><br />
</td>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output optionally scaled)
<p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</span>
</p>
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output MUST BE scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output MUST be scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output MUST be scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output MUST be scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td colspan="4"> <br />
</td></tr>
<tr>
<td rowspan="11"> RGB 24-bit embedded sync mode (CSC is used when output format is YUV)<br />
</td>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td>
<td> <br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> NONE<br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NONE<br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output MUST BE scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output MUST be scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(0,255,0)">YUV422 YUYV interleaved format (one output optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NO<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output MUST be scaled)</span><br />
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output MUST be scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,102,0)">RGB 24-bit interleaved format</span><br />
</td>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (optionally scaled)</span><br />
</td>
<td> NOT TESTED<br />
</td></tr>
<tr>
<td> <span style="background-color: rgb(255,204,153)">YUV420 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> <span style="background-color: rgb(0,255,255)">YUV422 Semi-planer format (one output optionally scaled)</span><br />
</td>
<td> NO
</td></tr></table>
<ul><li>In the table above,<br />Support = YES, means feature has been tested with current driver on current platform board/EVM.<br />Support = NO, means feature is not supported in current driver and using it will give unpredictable results. Feature is planned to be supported in future releases.<br />Support = NOT TESTED, means feature is present in driver but has NOT been tested on due to current platform board/EVM limitations AND/OR is planned to be tested in subsequent releases.<br /></li></ul>
<h2><span class="mw-headline" id="Limitations.2FIssues"><b>Limitations/Issues</b></span></h2>
<ul><li>There are limiations in capture driver for features like video source cable disconnect/connect, discrete sync mode, VIP parser overflow, Chroma downsampling. These limiations are related to Si issues. Please refer to Si Errata document to get latest update and workarounds for these issues.<br /></li></ul>
<p><br />
</p>
<h1><span class="mw-headline" id="Software_Application_Interfaces"><b>Software Application Interfaces</b></span></h1>
<p>The driver operation can be partitioned into the below phases: 
</p>
<ul><li>System Init Phase: Here the driver sub-system is initialized </li>
<li>Create Phase: Here the driver handle is created or instantiated </li>
<li>Control Phase: Control call to set the capture parameters. Here the driver, core and hal is initialized with the instance related setup parameters.</li>
<li>Run Phase: Here the driver is used to capture, process and release frames continuously </li>
<li>Delete Phase: Here the driver handle or instance is deallocated </li>
<li>System De-init Phase: Here the driver sub-system is de-initialized</li></ul>
<p>The subsequent sections describe each phase in detail. 
</p>
<h2><span class="mw-headline" id="System_Init_Phase"><b>System Init Phase</b></span></h2>
<p>The VIP capture driver sub-system initialization happens as part of overall system init. Below code shows the FVID2 API used to initialize the overall Capture subsystem. This API must be the the first API call before making any other FVID2 calls. 
</p><p>An example is shown below. Also shown in the example there is a FVID2 create API call to create the global VIP capture handle. This handle, as shown later, can be used to queue, dequeue frames from all active VIP ports.
In the below example, prior to the global VIP capture handle creation, BspUtils_appDefaultInit() routine is called. This function initializes the board, platform, fvid2, i2c, device drivers.
</p>
<pre>
static void CaptApp_init(CaptApp_Obj *appObj)
{
    Int32  retVal;
    UInt32 isI2cInitReq;

    /* System init */
    isI2cInitReq = TRUE;
    retVal       = BspUtils_appDefaultInit(isI2cInitReq);
    if (retVal&#160;!= FVID2_SOK)
    {
        GT_0trace(BspAppTrace, GT_ERR,
                  APP_NAME &quot;: System Init Failed!!!\n&quot;);
        return;
    }

    /* Create global capture handle, used for common driver configuration */
    appObj-&gt;fvidHandleAll = Fvid2_create(
        FVID2_VPS_CAPT_VID_DRV,
        VPS_CAPT_INST_ALL,
        NULL,                           /* NULL for VPS_CAPT_INST_ALL */
        NULL,                           /* NULL for VPS_CAPT_INST_ALL */
        NULL);                          /* NULL for VPS_CAPT_INST_ALL */
    if (NULL == appObj-&gt;fvidHandleAll)
    {
        GT_0trace(BspAppTrace, GT_ERR,
                  APP_NAME &quot;: Global Handle Create Failed!!!\n&quot;);
        return;
    }

    GT_0trace(BspAppTrace, GT_INFO,
              APP_NAME &quot;: CaptApp_init() - DONE&#160;!!!\n&quot;);

    return;
}
</pre>
<h2><span class="mw-headline" id="Create_Phase"><b>Create Phase</b></span></h2>
<p>In this phase user application opens or creates a driver instance. A driver instance is associated with one or more VIP instances, slices and parser ports depending on whether the operation mode is 8-bit or 16-bit or 24-bit.
Based on the VIP instance, slice and port information user can use the below routine to compute the instanceId to be passed to the Fvid2_Create() routine.
</p>
<pre>
/**
 *  \brief Macro to generate VIP capture driver instance ID to be passed
 *  during create parameter.
 *
 *  vipId   -   VPS_VIP1, VPS_VIP2 or VPS_VIP3&lt;br&gt;
 *  sliceId -   VPS_VIP_S0 or VPS_VIP_S1&lt;br&gt;
 *  portId  -   VPS_VIP_PORTA or VPS_VIP_PORTB
 */
#define VPS_CAPT_VIP_MAKE_INST_ID(vipId, sliceId, portId) \
    ((portId) +                                           \
     ((sliceId) * (VPS_VIP_PORT_MAX)) +                   \
     ((vipId) * (VPS_VIP_SLICE_MAX * VPS_VIP_PORT_MAX)))
</pre>
<h2><span class="mw-headline" id="Control_Phase"><b>Control Phase</b></span></h2>
<p>In this phase, user application provides the detailed set of capture VIP parameters to the driver.
</p>
<pre>
       retVal = Fvid2_control(
            instObj-&gt;drvHandle,
            IOCTL_VPS_CAPT_SET_VIP_PARAMS,
            &amp;instObj-&gt;vipPrms,
            NULL);
</pre>
<h3><span class="mw-headline" id="Driver_Instance_to_hardware_port_mapping_for_different_bus-widths"><b>Driver Instance to hardware port mapping</b> for different bus-widths</span></h3>
<p>The mapping of driver instance to VIP parser ports in HDVPSS is shown below: 
</p>
<table cellspacing="1" cellpadding="1" border="1" style="width: 679px; height: 66px;">

<tr>
<th scope="col"> VIP Instance<br />
</th>
<th scope="col"> Slice Id<br />
</th>
<th scope="col"> Port Id<br />
</th>
<th scope="col"> 8-bit interface<br />
</th>
<th scope="col"> 16-bit interface<br />
</th>
<th scope="col"> 24-bit interface<br />
</th></tr>
<tr>
<td> VIP 1 <br />
</td>
<td> Slice 0 <br />
</td>
<td> Port A <br />
</td>
<td> VIP1 S0 PortA<br />
</td>
<td> VIP1 S0 PortA<br />
</td>
<td> VIP1 S0 PortA<br />
</td></tr>
<tr>
<td> VIP 1 <br />
</td>
<td> Slice 0 <br />
</td>
<td> Port B <br />
</td>
<td> VIP1 S0 PortB<br />
</td>
<td> NOT&#160;USED<br />
</td>
<td> NOT&#160;USED<br />
</td></tr>
<tr>
<td> VIP 1 <br />
</td>
<td> Slice 1 <br />
</td>
<td> Port A <br />
</td>
<td> VIP1 S1 PortA<br />
</td>
<td> VIP1 S1 PortA<br />
</td>
<td> VIP1 S1 PortA<br />
</td></tr>
<tr>
<td> VIP 1 <br />
</td>
<td> Slice 1 <br />
</td>
<td> Port B <br />
</td>
<td> VIP1 S1 PortB<br />
</td>
<td> NOT&#160;USED<br />
</td>
<td> NOT&#160;USED<br />
</td></tr>
<tr>
<td> VIP 2 <br />
</td>
<td> Slice 0 <br />
</td>
<td> Port A <br />
</td>
<td> VIP2 S0 PortA<br />
</td>
<td> VIP2 S0 PortA<br />
</td>
<td> VIP2 S0 PortA<br />
</td></tr>
<tr>
<td> VIP 2 <br />
</td>
<td> Slice 0 <br />
</td>
<td> Port B <br />
</td>
<td> VIP2 S0 PortB<br />
</td>
<td> NOT&#160;USED<br />
</td>
<td> NOT&#160;USED<br />
</td></tr>
<tr>
<td> VIP 2 <br />
</td>
<td> Slice 1 <br />
</td>
<td> Port A <br />
</td>
<td> VIP2 S1 PortA<br />
</td>
<td> VIP2 S1 PortA<br />
</td>
<td> VIP2 S1 PortA<br />
</td></tr>
<tr>
<td> VIP 2 <br />
</td>
<td> Slice 1 <br />
</td>
<td> Port B <br />
</td>
<td> VIP2 S1 PortB<br />
</td>
<td> NOT&#160;USED<br />
</td>
<td> NOT&#160;USED<br />
</td></tr>

<tr>
<td> VIP 3 <br />
</td>
<td> Slice 0 <br />
</td>
<td> Port A <br />
</td>
<td> VIP3 S0 PortA<br />
</td>
<td> VIP3 S0 PortA<br />
</td>
<td> VIP3 S0 PortA<br />
</td></tr>
<tr>
<td> VIP 3 <br />
</td>
<td> Slice 0 <br />
</td>
<td> Port B <br />
</td>
<td> VIP3 S0 PortB<br />
</td>
<td> NOT&#160;USED<br />
</td>
<td> NOT&#160;USED<br />
</td></tr>
<tr>
<td> VIP 3 <br />
</td>
<td> Slice 1 <br />
</td>
<td> Port A <br />
</td>
<td> VIP3 S1 PortA<br />
</td>
<td> VIP3 S1 PortA<br />
</td>
<td> VIP3 S1 PortA<br />
</td></tr>
<tr>
<td> VIP 3 <br />
</td>
<td> Slice 1 <br />
</td>
<td> Port B <br />
</td>
<td> VIP3 S1 PortB<br />
</td>
<td> NOT&#160;USED<br />
</td>
<td> NOT&#160;USED<br />
</td></tr>
</table>
<p><br />
</p>
<h3><span class="mw-headline" id="Output_streams"><b>Output streams</b></span></h3>
<p>A maximum of four output streams (including VBI capture) are possible from the capture driver in non-multiplexed modes of capture. Data from each stream can be independently queued/dequeued when capture data streaming is enabled using Fvid2_start(). 
</p><p>Refer to table in previous section for valid supported input / output combinations for different input source formats.<br /> 
</p><p>Example of streams are: 
</p>
<ul><li>Single source dual format capture - YUV420 capture (stream 0) + RGB capture (stream 1) </li>
<li>Ancillary data capture - YUV422 capture (stream 0) + VBI capture (stream 1)</li></ul>
<div style="padding: 5px; background: none repeat scroll 0% 0% rgb(238, 238, 238); color: rgb(21, 27, 84);">
<p><b>NOTE</b><br /> Channel is different from stream in the sense that channel is associated with a distinct input source. For different output streams the input source (or channel) is the same, however the final output format - data format (RGB, YUV422, YUV420), or resolution, or data type (VBI, active data) - is different for each output stream. Thus when capturing 4CH D1 through one VIP port, number of valid channels will be four and output streams would be one (YUV422 format). However when capturing single channel 24-bit RGB, number of output streams can be three - YUV420 (stream 0), RGB 24-bit (stream 1), Ancillary data (stream 3).&#160;
Currently multi-channel or muxed mode capture is not supported by the VIP driver.
</p>
</div> 
<p><br />
</p>
<div style="padding: 5px; background: none repeat scroll 0% 0% rgb(238, 238, 238); color: rgb(21, 27, 84);">
<p><b>NOTE</b><br /> If FVID2_DF_YUV422SP_UV is used as output format, it must be the first output format (output format at the index 0 in outStreamInfo of Vps_CaptVipParams).&#160; 
</p>
</div> 
<p><br />
</p>
<h2><span class="mw-headline" id="Run_Phase"><b>Run Phase</b></span></h2>
<p>In this phase the driver can be used to start capture and continuously capture (dequeue) frame buffers from the driver and then process them and release (queue) them back to the driver. 
</p>
<h3><span class="mw-headline" id="Start_and_stop"><b>Start and stop</b></span></h3>
<p>Below API is used to start the capture. Once capture is started other FVID2 APIs can be used to dequeue and queue frame's continuously from the capture driver. 
</p>
<pre>
    /* Start driver */
    for (instCnt = 0u; instCnt &lt; appObj-&gt;testPrms.numHandles; instCnt++)
    {
        instObj = &amp;appObj-&gt;instObj[instCnt];

        retVal = Fvid2_start(instObj-&gt;drvHandle, NULL);
        if (retVal&#160;!= FVID2_SOK)
        {
            GT_0trace(BspAppTrace, GT_ERR,
                      APP_NAME &quot;: Capture Start Failed!!!\n&quot;);
            return;
        }
    }
</pre> 
<p>Below API is used to stop the capture. Capture can be started once again by using the FVID2 start API without having to create the driver once again. 
</p>
<pre>
    /* Stop driver */
    for (instCnt = 0u; instCnt &lt; appObj-&gt;testPrms.numHandles; instCnt++)
    {
        instObj = &amp;appObj-&gt;instObj[instCnt];
        retVal  = Fvid2_stop(instObj-&gt;drvHandle, NULL);
        if (retVal&#160;!= FVID2_SOK)
        {
            GT_0trace(BspAppTrace, GT_ERR,
                      APP_NAME &quot;: Capture Stop Failed!!!\n&quot;);
            return;
        }
    }
</pre> 
<h3><span class="mw-headline" id="Dequeueing-Queuing_frames"><b>Dequeueing-Queuing frames</b></span></h3>
<p>Once the capture is started as described above, below API can be used to dequeue captured frames from the capture driver. Once capture is started it starts capturing data in the frame buffer's allocated and queued during create phase. Once a frame is captured completely, it queue's the captured frame to its "completed" frame queue. Now when user calls dequeue the captured frames are given to the user application. 
</p><p>A single dequeue call can be used to dequeue multiple captured frames from multiple channels associated with that handle. Similarly a single queue can used to return multiple frames from different channels associated with that handle back to driver. 
</p><p><b>Example: Non-blocking dequeue from stream 0 for a capture handle</b> 
</p><p>The API used is a non-blocking API, i.e. API will return immediately with zero or more captured buffers.&#160; 
</p>
<pre>#include &quot;ti/psp/vps/vps_capture.h&quot;

Fvid2_FrameList       frameList;

status = Fvid2_dequeue(fvidHandle, &amp; frameList, 0, BIOS_NO_WAIT);
if(status!=FVID_SOK) {
  // error in dequeue-ing frames from capture handle
} else {
  // success, received 0 or more frames
  printf(&quot; Received&#160;%d frames\n&quot;, frameList.numFrames);
}
</pre> 
<p><b>Example: Dequeue from all active handles using a single API</b> 
</p><p>The global VIP handle, fvidHandleVipAll, is created by user during system init and can be used to dequeue/queue frames from all active (created) capture handles.&#160; 
</p>
<pre>#include &quot;ti/psp/vps/vps_capture.h&quot;

Fvid2_FrameList       frameList;

status = Fvid2_dequeue(fvidHandleVipAll, &amp; frameList, 0, BIOS_NO_WAIT);
if(status!=FVID_SOK) {
  // error in dequeue-ing frames from capture handle
} else {
  // success, received 0 or more frames
  printf(&quot; Received&#160;%d frames\n&quot;, frameList.numFrames);
}
</pre> 
<p><b>Example: Queue captured (dequeued) frames back to the driver</b> 
</p><p>The frame dequeued would typically be processed by user application like encoding, scaling etc and once user is done with the frame, user application should queue the frames back to the driver as shown below. Instead of instance specifc handle shown below, the global VIP capture driver handle can also be used to queue the frame back to the correct driver instance without the user having to worry about which handle the frames belong to.<br /> 
</p>
<pre>#include &quot;ti/psp/vps/vps_capture.h&quot;

Fvid2_FrameList       frameList;

status = Fvid2_queue(fvidHandle, &amp; frameList, 0);
if(status!=FVID_SOK) {
  // error in queue-ing frames to capture handle
} else {
  // success
}
</pre> <div style="padding: 5px; background: none repeat scroll 0% 0% rgb(238, 238, 238); color: rgb(21, 27, 84);">
<p><b>TIP</b><br /> User should make sure to dequeue / queue frames from the capture handle at the required rate (frame-rate), else the capture driver may not have frames internally to write video data and it will then be forced to drop frames until a buffer is available. 
</p>
</div> 
<h3><span class="mw-headline" id="Callback"><b>Callback</b></span></h3>
<p>A user callback can be registered during driver create which is then called by the driver whenever data is available at any of the channels, streams associated with the driver. User would typicall set a semaphore to wake up a task. The woken up task will then call dequeue API to get the newly captured frames. Dequeue should be called for every stream associated with the driver to get the captured frames, since the callback just indicates there is data but the data could be in any of the streams that are valid for the driver instance. 
</p>
<div style="padding: 5px; background: none repeat scroll 0% 0% rgb(238, 238, 238); color: rgb(21, 27, 84);">
<p><b>NOTE</b><br /> The callback itself could be called from interrupt or SWI context, so user should use only APIs that are allowed in interrupt or SWI context inside the callback. 
</p>
</div> 
<h3><span class="mw-headline" id="Understanding_captured_frame_information"><b>Understanding captured frame information</b></span></h3>
<p>Once a frame is captured the FVID2 frame structure contains information about the captured frame. The captured information can retrieved as shown below. The example below assumes "chNum" was created using the utility API&#160;Vps_captMakeChannelNum() during create. 
</p>
<pre>#include &quot;ti/psp/vps/vps_capture.h&quot;

Fvid2_FrameList       frameList;
Fvid2_Frame          *pCurFrame;
Vps_CaptRtParams     *pCaptureRtParams;

Int32 frameId;

Fvid2_dequeue(fvidHandleVipAll, &amp; frameList, 0, BIOS_WAIT_FOREVER);

System_printf(&quot; CAPTUREAPP: Received&#160;%d frame(s) \n&quot;, frameList.numFrames);

for(frameId=0; frameId &lt; frameList.numFrames; frameId++)
{
  pCurFrame = frameList.frames[frameId];

  pCaptureRtParams = (Vps_CaptRtParams*)pCurFrame-&gt;perFrameCfg;

  System_printf(&quot; CAPTUREAPP:&#160;%d: time&#160;%d: ch&#160;%d:%d:%d: fid&#160;%d:&#160;%dx%d: addr 0x%08x\n&quot;,
    frameId,
    pCurFrame-&gt;timeStamp,                      // timestamp in msecs
    Vps_captGetInstId(pCurFrame-&gt;chNum),       // VIP instance ID
    Vps_captGetStreamId(pCurFrame-&gt;chNum),// Stream ID
    Vps_captGetChId(pCurFrame-&gt;chNum),    // channel ID
    pCurFrame-&gt;fid,                            // Even or Odd field
    pCaptureRtParams-&gt;captureOutWidth,      // captured frame width
    pCaptureRtParams-&gt;captureOutHeight,     // captured frame height
    pCurFrame-&gt;addr[0][0]                      // captured buffer address for YUV422P format
               );
}

// process captured frames ...

...


Fvid2_queue(fvidHandleVipAll, &amp; frameList, 0);
</pre> <div style="padding: 5px; background: none repeat scroll 0% 0% rgb(238, 238, 238); color: rgb(21, 27, 84);">
<p><b>TIP</b><br /> Be careful to not modify the "Fvid2_Frame.perFrameCfg" from the received (dequeued) frame when returning (queuing) the frame back to the driver. If&#160;Fvid2_Frame.perFrameCfg has to be modified make sure user application sets it to a valid pointer in order to get captured frame width, height information from the driver, else set it to NULL. 
</p>
</div> 
<p><b>Understanding Fvid2_Frame.chNum</b> 
</p>
<div style="padding: 5px; background: none repeat scroll 0% 0% rgb(238, 238, 238); color: rgb(52, 128, 23);">
<p><b>Important</b><br /> Be careful to not modify the "Fvid2_Frame.chNum" from the received (dequeued) frame when returning (queuing) the frame back to the driver. The FVID2 queue API uses "chNum" to identify the VIP instance, stream and channel that the frame belongs to, in order to return it to the correct channel "free" queue. 
</p>
</div> 
<p>The below description is valid only when during create, channel number was made using the utility API Vps_captMakeChannelNum(). In case user had created channel number using their own logic they need to apply a inverse logic in order to know the instance, stream, channel associated with the received frame . 
</p><p>The capture driver assigns a unique channel number to every video channel, stream that is being captured via any of the VIP ports. User application needs to be aware of this assignment when handling frames from different VIP ports . 
</p><p>"Fvid2_Frame.chNum" identifies the channel associated with a given frame. Given "Fvid2_Frame.chNum" user application can find out the VIP instance, stream and channel ID using the APIs shown in above example. 
</p><p>The table below shows the channel number assignment for different VIP ports: 
</p>
<table width="40%" cellspacing="0" cellpadding="5" border="1">
<caption> <b>VIP port channel number assignment</b>
</caption>
<tr>
<th style="background-color: green;"> VIP Instance
</th>
<th style="background-color: green;"> Output Stream 0
</th>
<th style="background-color: green;"> Output Stream 1
</th>
<th style="background-color: green;"> Output Stream 2
</th>
<th style="background-color: green;"> Output Stream 3
</th></tr>
<tr>
<td> VIP0 Port A
</td>
<td> CH00 .. CH15
</td>
<td> CH16 .. CH31
</td>
<td> CH32 .. CH47
</td>
<td> CH48 .. CH63
</td></tr>
<tr>
<td> VIP0 Port B
</td>
<td> CH64 .. CH79
</td>
<td> CH80 .. CH95
</td>
<td> CH96 .. CH111
</td>
<td> CH112 .. CH127
</td></tr>
<tr>
<td> VIP1 Port A
</td>
<td> CH128 .. CH143
</td>
<td> CH144 .. CH159
</td>
<td> CH160 .. CH175
</td>
<td> CH176 .. CH191
</td></tr>
<tr>
<td> VIP1 Port B
</td>
<td> CH192 .. CH207
</td>
<td> CH208 .. CH223
</td>
<td> CH224 .. CH239
</td>
<td> CH240 .. CH255
</td></tr></table>
<p><br />
</p>
<h3><span class="mw-headline" id="Buffer_Capture_Mode_.28BCM.29"><b>Buffer Capture Mode (BCM)</b></span></h3>
<p>The section explains the design of the capture driver for various buffer capture mode. The decision of queuing and de-queuing a buffer to the core happens at the frame completion callback from the core which in turn is equivalent to VSYNC of the capture hardware. 
</p>
<ul><li><b>Frame drop mode</b></li></ul>
<p>In this mode the driver will stop capturing data when there are no more buffers at the input queue. The driver will not hold any buffer with it and the last buffer will be returned to the application through de-queue call. For this mode, the driver makes use of the VPDMA drop data feature.<br /> 
</p><p><br /> 
</p><p><a href="http://processors.wiki.ti.com/index.php/File:Frame_Drop_Mode_Buffer_Flow_(2).png" class="image"><img alt="Frame Drop Mode Buffer Flow (2).png" src="Frame_Drop_Mode_Buffer_Flow_(2).png" width="800" height="614" /></a><br /> 
</p><p><br /> 
</p><p><a href="http://processors.wiki.ti.com/index.php/File:Frame_Drop_Mode_ISR_Flow_Diagram.png" class="image"><img alt="Frame Drop Mode ISR Flow Diagram.png" src="Frame_Drop_Mode_ISR_Flow_Diagram.png" width="936" height="614" /></a><br /> 
</p><p><br /> 
</p>
<ul><li><b>Last frame repeat mode</b></li></ul>
<p>In this mode the driver will keep capturing the data to the last queued buffer when there are no more buffers at the input queue. The driver will hold the last buffer with it till the application queues any new buffer or the capture is stopped<br /> 
</p><p><a href="http://processors.wiki.ti.com/index.php/File:Last_Frame_Repeat_Mode_Buffer_Flow.png" class="image"><img alt="Last Frame Repeat Mode Buffer Flow.png" src="Last_Frame_Repeat_Mode_Buffer_Flow.png" width="800" height="614" /></a><br /> <br /> 
</p><p><a href="http://processors.wiki.ti.com/index.php/File:Last_Frame_Repeat_Mode_ISR_Flow_Diagram.png" class="image"><img alt="Last Frame Repeat Mode ISR Flow Diagram.png" src="Last_Frame_Repeat_Mode_ISR_Flow_Diagram.png" width="928" height="614" /></a><br /> 
</p>
<ul><li><b>Circular frame repeat mode</b></li></ul>
<p>In this mode the driver will keep reusing all the sets of buffer with it in a circular fashion. Application cannot get back any buffer from the driver when streaming is on and dequeue call will result in error.<br /> 
</p><p><a href="http://processors.wiki.ti.com/index.php/File:Circular_Frame_Repeat_Mode_Buffer_Flow.png" class="image"><img alt="Circular Frame Repeat Mode Buffer Flow.png" src="Circular_Frame_Repeat_Mode_Buffer_Flow.png" width="800" height="576" /></a> 
</p><p><br /> 
</p><p><a href="http://processors.wiki.ti.com/index.php/File:Circular_Frame_Repeat_Mode_ISR_Flow_Diagram.png" class="image"><img alt="Circular Frame Repeat Mode ISR Flow Diagram.png" src="Circular_Frame_Repeat_Mode_ISR_Flow_Diagram.png" width="928" height="576" /></a>
</p>
<h3><span class="mw-headline" id="Control_IOCTLs_supported"><b>Control IOCTLs supported</b></span></h3>
<h4><span class="mw-headline" id="Frame_skip_control_IOCTL_VPS_CAPT_SET_FRAME_SKIP"><b>Frame skip control IOCTL_VPS_CAPT_SET_FRAME_SKIP</b></span></h4>
<p>User can program a frame skip mask per channel to selectively skip frames. In this way user can control the frame-rate at which they want the data to be captured. When a frame is skipped, it is not written to DDR so that will also result in DDR bandwidth reduction. 
</p><p>This IOCTL can be called even while capture is running and frame-skip mask can be changed dynamically while capture is running. 
</p><p>An example is given below: 
</p>
<pre>#include &quot;ti/psp/vps/vps_capture.h&quot;

Vps_CaptFrameSkip frameSkip;

// chNum is the one that was specified by user during create in chNumMap[][]
frameSkip.chNum = createArgs.chNumMap[streamId][chId];

// Example: for full frame-rate
frameSkip.frameSkipMask = 0;

// Example: for 1/2 frame-rate
frameSkip.frameSkipMask = 0x2AAAAAAA;

status = Fvid2_control(
            fvidHandle,
            IOCTL_VPS_CAPT_SET_FRAME_SKIP,
            &amp; frameSkip,
            NULL
          );
</pre> 
<h4><span class="mw-headline" id="Get_Channel_Status_IOCTL_VPS_CAPT_GET_CH_STATUS"><b>Get Channel Status IOCTL_VPS_CAPT_GET_CH_STATUS</b></span></h4>
<p>This IOCTL allows user to get channel related information as detected by the hardware, like channel data width, height, video detect. 
</p><p>Width and height that is returned is the width and height of the last captured frame that hardware has detected. 
</p><p>Video detect status is calculated based on last received frame timestamp and expected frame interval. If a frame is not received in the given frame interval, then its considered as video is not detected. 
</p><p>Typically usage of this would be to periodically call this API from user context, say every 10ms or 30ms. User could then use this API to know detected video width and height and then allocate and queue buffers to the driver. 
</p><p>An example is shown below: 
</p>
<pre>#include &quot;ti/psp/vps/vps_capture.h&quot;

/*
  Check video detect status using IOCTL
*/
int status, chId, streamId;
Vps_CaptChGetStatusArgs chStatusArgs;
Vps_CaptChStatus chStatus

/* for all streams and channels */
for(streamId=0; streamId &lt; createArgs.numStream; streamId++)
{
  for(chId=0; chId &lt; createArgs.numCh; chId++)
  {

    chStatusArgs.chNum = createArgs.chNumMap[streamId][chId];

    /* expected frame capture interval between two frames/field in msecs  */
    chStatusArgs.frameInterval = 16;

    /* get video detect status  */
    status = Fvid2_control(
                fvidHandle,
                IOCTL_VPS_CAPT_GET_CH_STATUS,
                &amp; chStatusArgs,
                &amp; chStatus
              );

    if(chStatus.isVideoDetected)
    {
      /* video detect, print video info */
      System_printf(&quot; DETECT =&#160;%d:&#160;%dx%d\n&quot;,
                  chStatus.isVideoDetected,
                  chStatus.captureOutWidth,
                  chStatus.captureOutHeight
               );
    }
  }
}
</pre>
<p><br />
</p>
<h4><span class="mw-headline" id="Max_Size_IOCTL_VPS_CAPT_SET_VIP_MAX_SIZE"><b>Max Size IOCTL_VPS_CAPT_SET_VIP_MAX_SIZE</b></span></h4>
<p>User can program the three MAX_SIZE registers (MAX_SIZE_REG1, MAX_SIZE_REG2, MAX_SIZE_REG3) for each VPDMA associated with VIP1, VIP2, and VIP3 using this IOCTL. This IOCTL is valid only for Tda2xx. The Centaurus hardware does not have these registers present.
The user application can program these registers using the global VIP capture handle before even creating the driver handle for the actual capture instance.
</p><p>An example is given below: 
</p>
<pre>   
/**
 * There are 3 32-bit MAX_SIZE registers supported for Tda2xx platform family.
 * These registers provide two parameters width[31:16] and height[15:0].
 * The VPDMA transmits to external buffer the maximum out width number of
 * pixels and maximum out height number of pixel lines.
 * If the VIP receives data exceeding the maximum out width/height then it
 * continues to capture the data. VPDMA will not transfer it to the
 * external buffer.
 * This register (if used) should have valid range of values.
 * The valid range for maximum out width shall be [1, 4096]
 * The valid range for maximum out height shall be [1, 2048]
 * Example: For a YUV420SP capture,
 * For luma, the maximum out [width, height] can go up to [2048, 2048].
 * For chroma, the maximum out [width, height] can go up to [2048, 1024].
 * Example: For a YUV422I capture,
 * For luma, the maximum out [width, height] can go up to [4096, 2048].
 */
/* MAX SIZE Register Width and Height configurations */
#define CAPT_APP_MAXSIZE_1_WIDTH        (1920u)
#define CAPT_APP_MAXSIZE_2_WIDTH        (1920u)
#define CAPT_APP_MAXSIZE_3_WIDTH        (1280u)
#define CAPT_APP_MAXSIZE_1_HEIGHT       (1080u)
#define CAPT_APP_MAXSIZE_2_HEIGHT       (540u)
#define CAPT_APP_MAXSIZE_3_HEIGHT       (800u)
     
        instObj-&gt;maxOutWidth[0u]  = CAPT_APP_MAXSIZE_1_WIDTH;
        instObj-&gt;maxOutHeight[0u] = CAPT_APP_MAXSIZE_1_HEIGHT;
        instObj-&gt;maxOutWidth[1u]  = CAPT_APP_MAXSIZE_2_WIDTH;
        instObj-&gt;maxOutHeight[1u] = CAPT_APP_MAXSIZE_2_HEIGHT;
        instObj-&gt;maxOutWidth[2u]  = CAPT_APP_MAXSIZE_3_WIDTH;
        instObj-&gt;maxOutHeight[2u] = CAPT_APP_MAXSIZE_3_HEIGHT;

        if (Bsp_platformIsTda2xxFamilyBuild())
        {
            VpsVpdmaMaxSizeParams_init(&amp;vipMaxSizePrms);
            vipMaxSizePrms.instId =
                Vps_captGetVipId(appObj-&gt;testPrms.instId[instCnt]);
            vipMaxSizePrms.maxOutWidth[0u]  = instObj-&gt;maxOutWidth[0u];
            vipMaxSizePrms.maxOutHeight[0u] = instObj-&gt;maxOutHeight[0u];
            vipMaxSizePrms.maxOutWidth[1u]  = instObj-&gt;maxOutWidth[1u];
            vipMaxSizePrms.maxOutHeight[1u] = instObj-&gt;maxOutHeight[1u];
            vipMaxSizePrms.maxOutWidth[2u]  = instObj-&gt;maxOutWidth[2u];
            vipMaxSizePrms.maxOutHeight[2u] = instObj-&gt;maxOutHeight[2u];

            retVal = Fvid2_control(
                appObj-&gt;fvidHandleAll,
                IOCTL_VPS_CAPT_SET_VIP_MAX_SIZE,
                &amp;vipMaxSizePrms,
                NULL);
            if (retVal&#160;!= FVID2_SOK)
            {
                GT_0trace(
                    BspAppTrace, GT_ERR,
                    APP_NAME
                    &quot;: VIP Set Max Frame Size Params IOCTL Failed!!!\n&quot;);
                return;
            }
        }
</pre>
<h4><span class="mw-headline" id="Set_VIP_Parameters_IOCTL_VPS_CAPT_SET_VIP_PARAMS"><b>Set VIP Parameters IOCTL_VPS_CAPT_SET_VIP_PARAMS</b></span></h4>
<p>The application user after creating the instance handle shall need to make a control call with VIP specific parameters to configure the VIP blocks.
</p><p>An example is given below: 
</p>
<pre>        
        retVal = Fvid2_control(
            instObj-&gt;drvHandle,
            IOCTL_VPS_CAPT_SET_VIP_PARAMS,
            &amp;instObj-&gt;vipPrms,
            NULL);
        if (retVal&#160;!= FVID2_SOK)
        {
            GT_0trace(BspAppTrace, GT_ERR,
                      APP_NAME &quot;: VIP Set Params IOCTL Failed!!!\n&quot;);
            return;
        }
</pre>
<h4><span class="mw-headline" id="Get_VIP_Parameters_IOCTL_VPS_CAPT_GET_VIP_PARAMS"><b>Get VIP Parameters IOCTL_VPS_CAPT_GET_VIP_PARAMS</b></span></h4>
<p>The application user after creating the instance handle shall need to make a control call to get the default VIP parameters.
</p><p>An example is given below: 
</p>
<pre>        
        retVal = Fvid2_control(
            instObj-&gt;drvHandle,
            IOCTL_VPS_CAPT_GET_VIP_PARAMS,
            &amp;instObj-&gt;vipPrms,
            NULL);
        if (retVal&#160;!= FVID2_SOK)
        {
            GT_0trace(BspAppTrace, GT_ERR,
                      APP_NAME &quot;: VIP Get Params IOCTL Failed!!!\n&quot;);
            return;
        }
</pre>
<h2><span class="mw-headline" id="Delete_Phase"><b><br />Delete Phase</b></span></h2>
<p>In this phase FVID2 delete API is called to free all resources allocated during capture. Make sure capture is stopped using Fvid2_stop() before deleting a capture instance. Once a capture handle is deleted the resources free'ed by that capture handle could be used when another capture driver or other related driver is opened. 
</p><p>The FVID2 delete API call is shown below: 
</p>
<pre>
        retVal = Fvid2_delete(instObj-&gt;drvHandle, NULL);
        if (FVID2_SOK&#160;!= retVal)
        {
            GT_0trace(BspAppTrace, GT_ERR,
                      APP_NAME &quot;: Capture Delete Failed!!!\n&quot;);
            return;
        }
</pre>
<h2><span class="mw-headline" id="System_De-init_Phase"><b>System De-init Phase</b></span></h2>
<p>In this phase VIP capture sub-system is de-initialized. Here all resources acquired during system initialization are free'ed. Make sure all capture handles are deleted before calling this API. VIP sub-system de-init happens as part of overall FVID2 system de-init. Typically this is done during system shutdown. 
</p><p>The global VIP capture handle, if opened earlier, should also be deleted before called FVID2 de-init 
</p>
<pre>
static void CaptApp_deInit(CaptApp_Obj *appObj)
{
    Int32  retVal;
    UInt32 isI2cDeInitReq;

    /* Delete global VIP capture handle */
    retVal = Fvid2_delete(appObj-&gt;fvidHandleAll, NULL);
    if (retVal&#160;!= FVID2_SOK)
    {
        GT_0trace(BspAppTrace, GT_ERR,
                  APP_NAME &quot;: Global handle delete failed!!!\n&quot;);
        return;
    }

    /* System de-init */
    isI2cDeInitReq = TRUE;
    retVal         = BspUtils_appDefaultDeInit(isI2cDeInitReq);
    if (retVal&#160;!= FVID2_SOK)
    {
        GT_0trace(BspAppTrace, GT_ERR,
                  APP_NAME &quot;: System De-Init Failed!!!\n&quot;);
        return;
    }

    GT_0trace(BspAppTrace, GT_INFO,
              APP_NAME &quot;: CaptApp_deInit() - DONE&#160;!!!\n&quot;);
}
</pre> 
<p><br />
</p>
<!-- 
NewPP limit report
CPU time usage: 0.352 seconds
Real time usage: 0.423 seconds
Preprocessor visited node count: 328/1000000
Preprocessor generated node count: 612/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key davincid_wikidb:pcache:idhash:45039-0!*!*!!en!5!* and timestamp 20190103070806 and revision id 229115
 -->
<div class="hf-footer"></div><div class="hf-nsfooter"><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="http://processors.wiki.ti.com/index.php/File:E2e.jpg" class="image"><img alt="E2e.jpg" src="E2e.jpg" width="305" height="63" /></a>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external free" href="http://e2e.ti.com">http://e2e.ti.com</a>. Please post only comments about the article <b>PDK/PDK VPS Capture Driver User Guide</b> here.</i>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"> <a href="http://processors.wiki.ti.com/index.php/File:Hyperlink_blue.png" class="image"><img alt="Hyperlink blue.png" src="Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br />
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br />
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br />
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br />
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br />
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br />
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br />
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br />
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li> <a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li> <a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li> <a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li> <a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br />
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br />
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<p><!-- HitBox Sub accounts Code START -->
<script language="JavaScript" src="http://focus.ti.com/js/shared/metrics/metrics-min.js?version=1" type="text/javascript"></script>
<!-- HitBox Sub accounts Code END -->
</p>
<div id="tiPrivacy"></div>
</div></div>									<div class="printfooter">
						Retrieved from "<a dir="ltr" href="http://processors.wiki.ti.com/index.php?title=PDK/PDK_VPS_Capture_Driver_User_Guide&amp;oldid=229115">http://processors.wiki.ti.com/index.php?title=PDK/PDK_VPS_Capture_Driver_User_Guide&amp;oldid=229115</a>"					</div>
													<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://processors.wiki.ti.com/index.php/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="http://processors.wiki.ti.com/index.php/Category:Software_%26_Tools" title="Category:Software &amp; Tools">Software &amp; Tools</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="http://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=PDK%2FPDK+VPS+Capture+Driver+User+Guide" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="http://processors.wiki.ti.com/index.php/Special:RequestAccount" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
															<li  id="ca-nstab-main" class="selected"><span><a href="PDK_VPS_Capture_Driver_User_Guide.html"  title="View the content page [c]" accesskey="c">Page</a></span></li>
															<li  id="ca-talk" class="new"><span><a href="http://processors.wiki.ti.com/index.php?title=Talk:PDK/PDK_VPS_Capture_Driver_User_Guide&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label"><span>Variants</span><a href="PDK_VPS_Capture_Driver_User_Guide.html#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="PDK_VPS_Capture_Driver_User_Guide.html" >Read</a></span></li>
															<li id="ca-viewsource"><span><a href="http://processors.wiki.ti.com/index.php?title=PDK/PDK_VPS_Capture_Driver_User_Guide&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="http://processors.wiki.ti.com/index.php?title=PDK/PDK_VPS_Capture_Driver_User_Guide&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span><a href="PDK_VPS_Capture_Driver_User_Guide.html#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="http://processors.wiki.ti.com/index.php" id="searchform">
														<div id="simpleSearch">
															<input type="search" name="search" placeholder="Search" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="http://processors.wiki.ti.com/index.php/Main_Page"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
			<h3 id='p-navigation-label'>Navigation</h3>

			<div class="body">
									<ul>
													<li id="n-mainpage"><a href="http://processors.wiki.ti.com/index.php/Main_Page" title="Visit the main page [z]" accesskey="z">Main Page</a></li>
													<li id="n-All-pages"><a href="http://processors.wiki.ti.com/index.php/Special:AllPages">All pages</a></li>
													<li id="n-All-categories"><a href="http://processors.wiki.ti.com/index.php/Special:Categories">All categories</a></li>
													<li id="n-recentchanges"><a href="http://processors.wiki.ti.com/index.php/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
													<li id="n-randompage"><a href="http://processors.wiki.ti.com/index.php/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
													<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-coll-print_export' aria-labelledby='p-coll-print_export-label'>
			<h3 id='p-coll-print_export-label'>Print/export</h3>

			<div class="body">
									<ul>
													<li id="coll-create_a_book"><a href="http://processors.wiki.ti.com/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=PDK%2FPDK+VPS+Capture+Driver+User+Guide">Create a book</a></li>
													<li id="coll-download-as-rl"><a href="http://processors.wiki.ti.com/index.php?title=Special:Book&amp;bookcmd=render_article&amp;arttitle=PDK%2FPDK+VPS+Capture+Driver+User+Guide&amp;oldid=229115&amp;writer=rl">Download as PDF</a></li>
													<li id="t-print"><a href="http://processors.wiki.ti.com/index.php?title=PDK/PDK_VPS_Capture_Driver_User_Guide&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
			<h3 id='p-tb-label'>Toolbox</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="http://processors.wiki.ti.com/index.php/Special:WhatLinksHere/PDK/PDK_VPS_Capture_Driver_User_Guide" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
													<li id="t-recentchangeslinked"><a href="http://processors.wiki.ti.com/index.php/Special:RecentChangesLinked/PDK/PDK_VPS_Capture_Driver_User_Guide" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
													<li id="t-specialpages"><a href="http://processors.wiki.ti.com/index.php/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
													<li id="t-permalink"><a href="http://processors.wiki.ti.com/index.php?title=PDK/PDK_VPS_Capture_Driver_User_Guide&amp;oldid=229115" title="Permanent link to this revision of the page">Permanent link</a></li>
													<li id="t-info"><a href="http://processors.wiki.ti.com/index.php?title=PDK/PDK_VPS_Capture_Driver_User_Guide&amp;action=info" title="More information about this page">Page information</a></li>
											</ul>
							</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 1 July 2017, at 01:48.</li>
											<li id="footer-info-viewcount">This page has been accessed 2,217 times.</li>
											<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="http://processors.wiki.ti.com/index.php/Project:Privacy_policy" title="Project:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="http://processors.wiki.ti.com/index.php/Project:About" title="Project:About">About Texas Instruments Wiki</a></li>
											<li id="footer-places-disclaimer"><a href="http://processors.wiki.ti.com/index.php/Project:General_disclaimer" title="Project:General disclaimer">Disclaimers</a></li>
											<li id="footer-places-termsofservice"><a href="http://processors.wiki.ti.com/index.php/Project:Terms_of_Service" title="Project:Terms of Service">Terms of Use</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31" /></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="http://www.mediawiki.org/"><img src="poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" /></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>if(window.jQuery)jQuery.ready();</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"http://processors.wiki.ti.com/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=vector\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":744});
}</script>
	</body>
</html>
