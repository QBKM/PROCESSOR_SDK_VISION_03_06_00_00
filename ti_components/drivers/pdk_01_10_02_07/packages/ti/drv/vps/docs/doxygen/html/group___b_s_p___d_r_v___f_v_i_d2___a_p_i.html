<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>FVID2 API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FVID2 API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___b_s_p___d_r_v___i_o_c_t_l___f_v_i_d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___i_o_c_t_l___f_v_i_d2.html">FVID2 - Common IOCTL's</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:fvid2_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fvid2_8h.html">fvid2.h</a></td></tr>
<tr class="memdesc:fvid2_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">FVID2 API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_fvid2___cb_params.html">Fvid2_CbParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FVID2 callback parameters that are setup during <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1b6ddf776c756c47b7a6adcda5d2dc29" title="Creates the driver identified by the driver ID. ">Fvid2_create()</a>.  <a href="struct_fvid2___cb_params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_fvid2___process_list.html">Fvid2_ProcessList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FVID2 process list containing frame list's used to exchange multiple input/output buffers in M2M (memory to memory) operation.  <a href="struct_fvid2___process_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad4ca1a9ca475757e7437cf184ff8dba7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4ca1a9ca475757e7437cf184ff8dba7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gad4ca1a9ca475757e7437cf184ff8dba7">FVID2_VERSION_STRING</a>&#160;&#160;&#160;&quot;FVID_02_01_00_01&quot;</td></tr>
<tr class="memdesc:gad4ca1a9ca475757e7437cf184ff8dba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">FVID2 driver version string. Version is of the form mm_nn_xx_yy where, mm - Product version (02 for FVID2). This increments for any new FVID2 versions. nn - Major number - Increments if any backward compatibility is broken or major change within a product version. xx - Minor number - Increments for any minor change or any additions done without breaking backward compatibility. yy - Build number - Increments for every release. <br /></td></tr>
<tr class="separator:gad4ca1a9ca475757e7437cf184ff8dba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga011cd2af94c0c4a8b3e3e15d83eae915"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga011cd2af94c0c4a8b3e3e15d83eae915"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga011cd2af94c0c4a8b3e3e15d83eae915">FVID2_VERSION_NUMBER</a>&#160;&#160;&#160;(0x02010001U)</td></tr>
<tr class="memdesc:ga011cd2af94c0c4a8b3e3e15d83eae915"><td class="mdescLeft">&#160;</td><td class="mdescRight">FVID2 driver version number. <br /></td></tr>
<tr class="separator:ga011cd2af94c0c4a8b3e3e15d83eae915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4461d6511558ab1d92ccda088a0f61c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa4461d6511558ab1d92ccda088a0f61c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaa4461d6511558ab1d92ccda088a0f61c">FVID2_CTRL_BASE</a>&#160;&#160;&#160;(0x00000000U)</td></tr>
<tr class="memdesc:gaa4461d6511558ab1d92ccda088a0f61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control command base address. <br /></td></tr>
<tr class="separator:gaa4461d6511558ab1d92ccda088a0f61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb1503166a8ee0272a4e48c483e85e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeeb1503166a8ee0272a4e48c483e85e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaeeb1503166a8ee0272a4e48c483e85e3">FVID2_USER_BASE</a>&#160;&#160;&#160;(0x10000000U)</td></tr>
<tr class="memdesc:gaeeb1503166a8ee0272a4e48c483e85e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">User command base address. <br /></td></tr>
<tr class="separator:gaeeb1503166a8ee0272a4e48c483e85e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga70385ba792f5870018ee2f3ce413f3c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70385ba792f5870018ee2f3ce413f3c1"></a>
typedef Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a></td></tr>
<tr class="memdesc:ga70385ba792f5870018ee2f3ce413f3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">FVID2 Driver handle. <br /></td></tr>
<tr class="separator:ga70385ba792f5870018ee2f3ce413f3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7005b139e3b5e75db5b6d758ea316d9f"><td class="memItemLeft" align="right" valign="top">typedef Int32(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga7005b139e3b5e75db5b6d758ea316d9f">Fvid2_CbFxn</a>) (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, Ptr appData, Ptr reserved)</td></tr>
<tr class="memdesc:ga7005b139e3b5e75db5b6d758ea316d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">FVID2 driver callback function prototype.  <a href="#ga7005b139e3b5e75db5b6d758ea316d9f">More...</a><br /></td></tr>
<tr class="separator:ga7005b139e3b5e75db5b6d758ea316d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecfc459d02a9c452b421806231c74137"><td class="memItemLeft" align="right" valign="top">typedef Int32(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaecfc459d02a9c452b421806231c74137">Fvid2_ErrCbFxn</a>) (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, Ptr appData, Ptr errList, Ptr reserved)</td></tr>
<tr class="memdesc:gaecfc459d02a9c452b421806231c74137"><td class="mdescLeft">&#160;</td><td class="mdescRight">FVID2 error callback function prototype.  <a href="#gaecfc459d02a9c452b421806231c74137">More...</a><br /></td></tr>
<tr class="separator:gaecfc459d02a9c452b421806231c74137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2f6d55ca4de8dc2972f6b0989be0897"><td class="memItemLeft" align="right" valign="top">typedef Int32(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaa2f6d55ca4de8dc2972f6b0989be0897">Fvid2_SubFrameCbFxn</a>) (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, <a class="el" href="struct_fvid2___frame.html">Fvid2_Frame</a> *subFrame)</td></tr>
<tr class="memdesc:gaa2f6d55ca4de8dc2972f6b0989be0897"><td class="mdescLeft">&#160;</td><td class="mdescRight">FVID2 callback that is called by subframe mode Capture driver.  <a href="#gaa2f6d55ca4de8dc2972f6b0989be0897">More...</a><br /></td></tr>
<tr class="separator:gaa2f6d55ca4de8dc2972f6b0989be0897"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1da9c9b598dfc36350c1afb0af1cba45"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1da9c9b598dfc36350c1afb0af1cba45">Fvid2_init</a> (Ptr args)</td></tr>
<tr class="memdesc:ga1da9c9b598dfc36350c1afb0af1cba45"><td class="mdescLeft">&#160;</td><td class="mdescRight">FVID2 init function.  <a href="#ga1da9c9b598dfc36350c1afb0af1cba45">More...</a><br /></td></tr>
<tr class="separator:ga1da9c9b598dfc36350c1afb0af1cba45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a3b2aa6dea4ba11e8bfbf888770a64"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaa8a3b2aa6dea4ba11e8bfbf888770a64">Fvid2_deInit</a> (Ptr args)</td></tr>
<tr class="memdesc:gaa8a3b2aa6dea4ba11e8bfbf888770a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">FVID2 deinit function.  <a href="#gaa8a3b2aa6dea4ba11e8bfbf888770a64">More...</a><br /></td></tr>
<tr class="separator:gaa8a3b2aa6dea4ba11e8bfbf888770a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84aceedf7244d24c40d051cb9f4a3c67"><td class="memItemLeft" align="right" valign="top">const Char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga84aceedf7244d24c40d051cb9f4a3c67">Fvid2_getVersionString</a> (void)</td></tr>
<tr class="memdesc:ga84aceedf7244d24c40d051cb9f4a3c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the version string for FVID2 interface.  <a href="#ga84aceedf7244d24c40d051cb9f4a3c67">More...</a><br /></td></tr>
<tr class="separator:ga84aceedf7244d24c40d051cb9f4a3c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072c6a6771e5a9bfd6edbec4a9a60bb5"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga072c6a6771e5a9bfd6edbec4a9a60bb5">Fvid2_getVersionNumber</a> (void)</td></tr>
<tr class="memdesc:ga072c6a6771e5a9bfd6edbec4a9a60bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga84aceedf7244d24c40d051cb9f4a3c67" title="Get the version string for FVID2 interface. ">Fvid2_getVersionString()</a> except it returns the version in UInt32 form.  <a href="#ga072c6a6771e5a9bfd6edbec4a9a60bb5">More...</a><br /></td></tr>
<tr class="separator:ga072c6a6771e5a9bfd6edbec4a9a60bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6ddf776c756c47b7a6adcda5d2dc29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1b6ddf776c756c47b7a6adcda5d2dc29">Fvid2_create</a> (UInt32 drvId, UInt32 instanceId, Ptr createArgs, Ptr createStatusArgs, const <a class="el" href="struct_fvid2___cb_params.html">Fvid2_CbParams</a> *cbParams)</td></tr>
<tr class="memdesc:ga1b6ddf776c756c47b7a6adcda5d2dc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the driver identified by the driver ID.  <a href="#ga1b6ddf776c756c47b7a6adcda5d2dc29">More...</a><br /></td></tr>
<tr class="separator:ga1b6ddf776c756c47b7a6adcda5d2dc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da431a59e7ced66bead6ea6ec27fc7c"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga9da431a59e7ced66bead6ea6ec27fc7c">Fvid2_delete</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, Ptr deleteArgs)</td></tr>
<tr class="memdesc:ga9da431a59e7ced66bead6ea6ec27fc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a previously created FVID2 driver handle.  <a href="#ga9da431a59e7ced66bead6ea6ec27fc7c">More...</a><br /></td></tr>
<tr class="separator:ga9da431a59e7ced66bead6ea6ec27fc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0b991cddc848f77a78b0d652a1847f"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gabd0b991cddc848f77a78b0d652a1847f">Fvid2_control</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, UInt32 cmd, Ptr cmdArgs, Ptr cmdStatusArgs)</td></tr>
<tr class="memdesc:gabd0b991cddc848f77a78b0d652a1847f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send control commands (IOCTLs) to the driver.  <a href="#gabd0b991cddc848f77a78b0d652a1847f">More...</a><br /></td></tr>
<tr class="separator:gabd0b991cddc848f77a78b0d652a1847f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546aa58a2d6444eaa6e17bb065cef401"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga546aa58a2d6444eaa6e17bb065cef401">Fvid2_queue</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, <a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *frameList, UInt32 streamId)</td></tr>
<tr class="memdesc:ga546aa58a2d6444eaa6e17bb065cef401"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application calls Fvid2_queue to submit a video buffer to the video device driver.  <a href="#ga546aa58a2d6444eaa6e17bb065cef401">More...</a><br /></td></tr>
<tr class="separator:ga546aa58a2d6444eaa6e17bb065cef401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga895bfc7dfdc1564829ab9e92afd89b56"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga895bfc7dfdc1564829ab9e92afd89b56">Fvid2_dequeue</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, <a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *frameList, UInt32 streamId, UInt32 timeout)</td></tr>
<tr class="memdesc:ga895bfc7dfdc1564829ab9e92afd89b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application calls Fvid2_dequeue to request the video device driver to give ownership of a video buffer.  <a href="#ga895bfc7dfdc1564829ab9e92afd89b56">More...</a><br /></td></tr>
<tr class="separator:ga895bfc7dfdc1564829ab9e92afd89b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae97f8ae2198d5891ee8511277f40675f"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gae97f8ae2198d5891ee8511277f40675f">Fvid2_processFrames</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, <a class="el" href="struct_fvid2___process_list.html">Fvid2_ProcessList</a> *processList)</td></tr>
<tr class="memdesc:gae97f8ae2198d5891ee8511277f40675f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application calls Fvid2_processFrames to submit a video buffer to the video device driver.  <a href="#gae97f8ae2198d5891ee8511277f40675f">More...</a><br /></td></tr>
<tr class="separator:gae97f8ae2198d5891ee8511277f40675f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba44221afaaa45005ef0e7baf4c8c2ce"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaba44221afaaa45005ef0e7baf4c8c2ce">Fvid2_getProcessedFrames</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, <a class="el" href="struct_fvid2___process_list.html">Fvid2_ProcessList</a> *processList, UInt32 timeout)</td></tr>
<tr class="memdesc:gaba44221afaaa45005ef0e7baf4c8c2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application calls Fvid2_getProcessedFrames to request the video device driver to give ownership of a video buffer.  <a href="#gaba44221afaaa45005ef0e7baf4c8c2ce">More...</a><br /></td></tr>
<tr class="separator:gaba44221afaaa45005ef0e7baf4c8c2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b905328ed0b067fdc73b39cdbfeec1b"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga0b905328ed0b067fdc73b39cdbfeec1b">Fvid2_processRequest</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, <a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *inFrameList, <a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *outFrameList)</td></tr>
<tr class="memdesc:ga0b905328ed0b067fdc73b39cdbfeec1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application calls Fvid2_processRequest to submit a video buffer to the video device driver.  <a href="#ga0b905328ed0b067fdc73b39cdbfeec1b">More...</a><br /></td></tr>
<tr class="separator:ga0b905328ed0b067fdc73b39cdbfeec1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe8881d838a04fc52d0339886b68874"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga0fe8881d838a04fc52d0339886b68874">Fvid2_getProcessedRequest</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, <a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *inFrameList, <a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *outFrameList, UInt32 timeout)</td></tr>
<tr class="memdesc:ga0fe8881d838a04fc52d0339886b68874"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application calls Fvid2_getProcessedRequest to get the processed request back from the driver and thus to get the ownership of request back from the driver.  <a href="#ga0fe8881d838a04fc52d0339886b68874">More...</a><br /></td></tr>
<tr class="separator:ga0fe8881d838a04fc52d0339886b68874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0345d6a47c9b678cccde6a8b4c8660cd"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga0345d6a47c9b678cccde6a8b4c8660cd">Fvid2_start</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, Ptr cmdArgs)</td></tr>
<tr class="memdesc:ga0345d6a47c9b678cccde6a8b4c8660cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application calls Fvid2_start to request the video device driver to start the video display or capture operation. This function should be called from task context only and should not be called from ISR context.  <a href="#ga0345d6a47c9b678cccde6a8b4c8660cd">More...</a><br /></td></tr>
<tr class="separator:ga0345d6a47c9b678cccde6a8b4c8660cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee331b26ea04f78c1d57aaedfd8fa39f"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaee331b26ea04f78c1d57aaedfd8fa39f">Fvid2_stop</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, Ptr cmdArgs)</td></tr>
<tr class="memdesc:gaee331b26ea04f78c1d57aaedfd8fa39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application calls Fvid2_stop to request the video device driver to stop the video display or capture operation. This function should be called from task context only and should not be called from ISR context.  <a href="#gaee331b26ea04f78c1d57aaedfd8fa39f">More...</a><br /></td></tr>
<tr class="separator:gaee331b26ea04f78c1d57aaedfd8fa39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050dbd9b1eebd6ec0ba63178ea17eca5"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga050dbd9b1eebd6ec0ba63178ea17eca5">Fvid2_setFormat</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, <a class="el" href="struct_fvid2___format.html">Fvid2_Format</a> *fmt)</td></tr>
<tr class="memdesc:ga050dbd9b1eebd6ec0ba63178ea17eca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application calls Fvid2_setFormat to request the video device driver to set the format for a given channel. This function should be called from task context only and should not be called from ISR context.  <a href="#ga050dbd9b1eebd6ec0ba63178ea17eca5">More...</a><br /></td></tr>
<tr class="separator:ga050dbd9b1eebd6ec0ba63178ea17eca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga995a3f6e9e95152e1a4dfd4525761eb2"><td class="memItemLeft" align="right" valign="top">static Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga995a3f6e9e95152e1a4dfd4525761eb2">Fvid2_getFormat</a> (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, <a class="el" href="struct_fvid2___format.html">Fvid2_Format</a> *fmt)</td></tr>
<tr class="memdesc:ga995a3f6e9e95152e1a4dfd4525761eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application calls Fvid2_getFormat to request the video device driver to get the current format for a given channel. This function should be called from task context only and should not be called from ISR context.  <a href="#ga995a3f6e9e95152e1a4dfd4525761eb2">More...</a><br /></td></tr>
<tr class="separator:ga995a3f6e9e95152e1a4dfd4525761eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dea4a8dfac43f4c151775a2a7af4cab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga3dea4a8dfac43f4c151775a2a7af4cab">Fvid2CbParams_init</a> (<a class="el" href="struct_fvid2___cb_params.html">Fvid2_CbParams</a> *cbPrms)</td></tr>
<tr class="memdesc:ga3dea4a8dfac43f4c151775a2a7af4cab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_fvid2___cb_params.html" title="FVID2 callback parameters that are setup during Fvid2_create(). ">Fvid2_CbParams</a> structure init function.  <a href="#ga3dea4a8dfac43f4c151775a2a7af4cab">More...</a><br /></td></tr>
<tr class="separator:ga3dea4a8dfac43f4c151775a2a7af4cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga903495c2de873a3f0522596acf87bb21"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga903495c2de873a3f0522596acf87bb21">Fvid2ProcessList_init</a> (<a class="el" href="struct_fvid2___process_list.html">Fvid2_ProcessList</a> *pList)</td></tr>
<tr class="memdesc:ga903495c2de873a3f0522596acf87bb21"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_fvid2___process_list.html" title="FVID2 process list containing frame list&#39;s used to exchange multiple input/output buffers in M2M (mem...">Fvid2_ProcessList</a> structure init function.  <a href="#ga903495c2de873a3f0522596acf87bb21">More...</a><br /></td></tr>
<tr class="separator:ga903495c2de873a3f0522596acf87bb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
FVID2 Max limits</h2></td></tr>
<tr class="memitem:gac66072d4782aab7b1e52630fd8d81cf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac66072d4782aab7b1e52630fd8d81cf5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gac66072d4782aab7b1e52630fd8d81cf5">FVID2_MAX_IN_OUT_PROCESS_LISTS</a>&#160;&#160;&#160;(4U)</td></tr>
<tr class="memdesc:gac66072d4782aab7b1e52630fd8d81cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of IN/OUT frame list per process list - Used for array allocation in process list structure. <br /></td></tr>
<tr class="separator:gac66072d4782aab7b1e52630fd8d81cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e74a5199d9a728bc5ad8051be3b8de3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2e74a5199d9a728bc5ad8051be3b8de3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga2e74a5199d9a728bc5ad8051be3b8de3">FVID2_STREAM_ID_ANY</a>&#160;&#160;&#160;(0xFFFFFFFFU)</td></tr>
<tr class="memdesc:ga2e74a5199d9a728bc5ad8051be3b8de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide the streamid based on channel number. <br /></td></tr>
<tr class="separator:ga2e74a5199d9a728bc5ad8051be3b8de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>FVID2 API is an interface which is used to create, control and use different video drivers. FVID2 API is used not only for on-chip peripherals drivers like capture, display but also for external off-chip video device peripherals like video decoders, video encoders and video sensors.</p>
<p>All BSP video drivers and external video peripherals implement the FVID2 API. Many drivers also extend the FVID2 interface by defining their own driver specific IOCTLs.</p>
<p><b> All FVID2 API must be called from task context </b>. Some examples in the BSP package maybe calling FVID2 APIs from callback and/or interrupt context. Such examples will be modified in subsequent releases and in order that user application do not have to do special migration it is strongly recommended to use FVID2 APIs only from task context.</p>
<p>A FVID2 API can be of two kinds,</p>
<ul>
<li><b> Blocking API </b> <br />
 Here the FVID2 API call returns only after completing the request or functionality or if timed out or if some other error occurs. The below APIs are always blocking, unless specified otherwise by specific driver.<ul>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1b6ddf776c756c47b7a6adcda5d2dc29" title="Creates the driver identified by the driver ID. ">Fvid2_create()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga9da431a59e7ced66bead6ea6ec27fc7c" title="Deletes a previously created FVID2 driver handle. ">Fvid2_delete()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga0345d6a47c9b678cccde6a8b4c8660cd" title="An application calls Fvid2_start to request the video device driver to start the video display or cap...">Fvid2_start()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaee331b26ea04f78c1d57aaedfd8fa39f" title="An application calls Fvid2_stop to request the video device driver to stop the video display or captu...">Fvid2_stop()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gabd0b991cddc848f77a78b0d652a1847f" title="Send control commands (IOCTLs) to the driver. ">Fvid2_control()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga050dbd9b1eebd6ec0ba63178ea17eca5" title="An application calls Fvid2_setFormat to request the video device driver to set the format for a given...">Fvid2_setFormat()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga995a3f6e9e95152e1a4dfd4525761eb2" title="An application calls Fvid2_getFormat to request the video device driver to get the current format for...">Fvid2_getFormat()</a></li>
</ul>
</li>
<li><b> Non-blocking API </b> <br />
 Here FVID2 API call queues the request to the driver and returns immediately before the request is processed or completed. Application should use the completion callback to wait for request completion. The below APIs are always non-blocking, unless specified otherwise by specific driver.<ul>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga546aa58a2d6444eaa6e17bb065cef401" title="An application calls Fvid2_queue to submit a video buffer to the video device driver. ">Fvid2_queue()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga895bfc7dfdc1564829ab9e92afd89b56" title="An application calls Fvid2_dequeue to request the video device driver to give ownership of a video bu...">Fvid2_dequeue()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gae97f8ae2198d5891ee8511277f40675f" title="An application calls Fvid2_processFrames to submit a video buffer to the video device driver...">Fvid2_processFrames()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaba44221afaaa45005ef0e7baf4c8c2ce" title="An application calls Fvid2_getProcessedFrames to request the video device driver to give ownership of...">Fvid2_getProcessedFrames()</a></li>
</ul>
</li>
</ul>
<p>A FVID2 Driver can belong to one the below categories. The FVID2 APIs applicable to driver in a category are also listed below. The below is true for most driver unless specified otherwise by a specific driver.</p><ul>
<li><b> Streaming interface drivers </b> <br />
 Examples include, capture, display, graphics. Below FVID2 APIs are implemented by such drivers.<ul>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1b6ddf776c756c47b7a6adcda5d2dc29" title="Creates the driver identified by the driver ID. ">Fvid2_create()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga9da431a59e7ced66bead6ea6ec27fc7c" title="Deletes a previously created FVID2 driver handle. ">Fvid2_delete()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga0345d6a47c9b678cccde6a8b4c8660cd" title="An application calls Fvid2_start to request the video device driver to start the video display or cap...">Fvid2_start()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaee331b26ea04f78c1d57aaedfd8fa39f" title="An application calls Fvid2_stop to request the video device driver to stop the video display or captu...">Fvid2_stop()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga546aa58a2d6444eaa6e17bb065cef401" title="An application calls Fvid2_queue to submit a video buffer to the video device driver. ">Fvid2_queue()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga895bfc7dfdc1564829ab9e92afd89b56" title="An application calls Fvid2_dequeue to request the video device driver to give ownership of a video bu...">Fvid2_dequeue()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gabd0b991cddc848f77a78b0d652a1847f" title="Send control commands (IOCTLs) to the driver. ">Fvid2_control()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga050dbd9b1eebd6ec0ba63178ea17eca5" title="An application calls Fvid2_setFormat to request the video device driver to set the format for a given...">Fvid2_setFormat()</a> - OPTIONAL</li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga995a3f6e9e95152e1a4dfd4525761eb2" title="An application calls Fvid2_getFormat to request the video device driver to get the current format for...">Fvid2_getFormat()</a> - OPTIONAL</li>
</ul>
</li>
<li><b> Memory to memory processing interface drivers </b> <br />
 Examples include, M2M VPE. Below FVID2 APIs are implemented by such drivers.<ul>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1b6ddf776c756c47b7a6adcda5d2dc29" title="Creates the driver identified by the driver ID. ">Fvid2_create()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga9da431a59e7ced66bead6ea6ec27fc7c" title="Deletes a previously created FVID2 driver handle. ">Fvid2_delete()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gae97f8ae2198d5891ee8511277f40675f" title="An application calls Fvid2_processFrames to submit a video buffer to the video device driver...">Fvid2_processFrames()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaba44221afaaa45005ef0e7baf4c8c2ce" title="An application calls Fvid2_getProcessedFrames to request the video device driver to give ownership of...">Fvid2_getProcessedFrames()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gabd0b991cddc848f77a78b0d652a1847f" title="Send control commands (IOCTLs) to the driver. ">Fvid2_control()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga050dbd9b1eebd6ec0ba63178ea17eca5" title="An application calls Fvid2_setFormat to request the video device driver to set the format for a given...">Fvid2_setFormat()</a> - OPTIONAL</li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga995a3f6e9e95152e1a4dfd4525761eb2" title="An application calls Fvid2_getFormat to request the video device driver to get the current format for...">Fvid2_getFormat()</a> - OPTIONAL</li>
</ul>
</li>
<li><b> Control interface drivers </b> <br />
 Examples include, display controller, external video devices. Below FVID2 APIs are implemented by such drivers.<ul>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1b6ddf776c756c47b7a6adcda5d2dc29" title="Creates the driver identified by the driver ID. ">Fvid2_create()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga9da431a59e7ced66bead6ea6ec27fc7c" title="Deletes a previously created FVID2 driver handle. ">Fvid2_delete()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gabd0b991cddc848f77a78b0d652a1847f" title="Send control commands (IOCTLs) to the driver. ">Fvid2_control()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga0345d6a47c9b678cccde6a8b4c8660cd" title="An application calls Fvid2_start to request the video device driver to start the video display or cap...">Fvid2_start()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaee331b26ea04f78c1d57aaedfd8fa39f" title="An application calls Fvid2_stop to request the video device driver to stop the video display or captu...">Fvid2_stop()</a></li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga050dbd9b1eebd6ec0ba63178ea17eca5" title="An application calls Fvid2_setFormat to request the video device driver to set the format for a given...">Fvid2_setFormat()</a> - OPTIONAL</li>
<li><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga995a3f6e9e95152e1a4dfd4525761eb2" title="An application calls Fvid2_getFormat to request the video device driver to get the current format for...">Fvid2_getFormat()</a> - OPTIONAL</li>
</ul>
</li>
</ul>
<p>Before making any FVID2 API calls, <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1da9c9b598dfc36350c1afb0af1cba45" title="FVID2 init function. ">Fvid2_init()</a> must be called. <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaa8a3b2aa6dea4ba11e8bfbf888770a64" title="FVID2 deinit function. ">Fvid2_deInit()</a> must be called during system shutdown.</p>
<p><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga84aceedf7244d24c40d051cb9f4a3c67" title="Get the version string for FVID2 interface. ">Fvid2_getVersionString()</a> and <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga072c6a6771e5a9bfd6edbec4a9a60bb5" title="Same as Fvid2_getVersionString() except it returns the version in UInt32 form. ">Fvid2_getVersionNumber()</a> can be used to get information about current driver version number.</p>
<p>All FVID2 drivers are of type Fvid2_Handle, which gets created when <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1b6ddf776c756c47b7a6adcda5d2dc29" title="Creates the driver identified by the driver ID. ">Fvid2_create()</a> is called. This handle is used for all subsequent FVID2 API calls. This handle and its associated resources are free'ed when <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga9da431a59e7ced66bead6ea6ec27fc7c" title="Deletes a previously created FVID2 driver handle. ">Fvid2_delete()</a> is called.</p>
<p>All FVID2 APIs make use of <a class="el" href="struct_fvid2___frame.html" title="FVID2 frame buffer structure. ">Fvid2_Frame</a>, <a class="el" href="struct_fvid2___frame_list.html" title="FVID2 frame buffer list used to exchange multiple FVID2 frames in a single driver call...">Fvid2_FrameList</a> and/or <a class="el" href="struct_fvid2___process_list.html" title="FVID2 process list containing frame list&#39;s used to exchange multiple input/output buffers in M2M (mem...">Fvid2_ProcessList</a> for exchanging and processing video frames via a driver. Further all drivers use a common user callback mechanism via <a class="el" href="struct_fvid2___cb_params.html" title="FVID2 callback parameters that are setup during Fvid2_create(). ">Fvid2_CbParams</a> to indicate to the user that a frame is ready. Many drivers, but not all, use the <a class="el" href="struct_fvid2___format.html" title="FVID2 video buffer format specification. ">Fvid2_Format</a> data structure to describe video input, output data formats.</p>
<p>All drivers use the constants, enum's, error codes defined in this file to control and configure a driver.</p>
<p>In addition, most drivers define driver specific create time parameters and IOCTLs to allow the user to control and configure the driver in driver specific ways. Further a driver may define driver specific run-time parameters which are passed by user to the driver via <a class="el" href="struct_fvid2___frame.html#a564a3b5b496153dd2de09626a4c71e25">Fvid2_Frame.perFrameCfg</a> and/or <a class="el" href="struct_fvid2___frame_list.html#acdf7697be2979d7e86079ff7cae66206">Fvid2_FrameList.perListCfg</a>.</p>
<p>Also user application can associate user specific app data with a driver handle via <a class="el" href="struct_fvid2___cb_params.html#a036d13c134153f6b669faba474bd3deb">Fvid2_CbParams.appData</a> or with every frame via FIVD2_Frame.appData. The app data set as part of <a class="el" href="struct_fvid2___cb_params.html" title="FVID2 callback parameters that are setup during Fvid2_create(). ">Fvid2_CbParams</a> returned back to user when callback occurs. The app data set as part of <a class="el" href="struct_fvid2___frame.html" title="FVID2 frame buffer structure. ">Fvid2_Frame</a> is returned back to the user when the <a class="el" href="struct_fvid2___frame.html" title="FVID2 frame buffer structure. ">Fvid2_Frame</a> itself is returned back to user via <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga895bfc7dfdc1564829ab9e92afd89b56" title="An application calls Fvid2_dequeue to request the video device driver to give ownership of a video bu...">Fvid2_dequeue()</a> or <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#gaba44221afaaa45005ef0e7baf4c8c2ce" title="An application calls Fvid2_getProcessedFrames to request the video device driver to give ownership of...">Fvid2_getProcessedFrames()</a>. The driver will not modify this app data. This could be used by the application to store any application specific data like application object info and so on.</p>
<p>Many FVID2 APIs define 'reserved' fields. These are meant for future use and should be set to NULL/zero by user. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga7005b139e3b5e75db5b6d758ea316d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Int32(* Fvid2_CbFxn) (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, Ptr appData, Ptr reserved)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FVID2 driver callback function prototype. </p>
<p>This callback is used by the drivers which implement non-blocking FVID2 APIs.</p>
<p>User should assume that callbacks happen in ISR context and hence should apply rules relevant to ISR context when implementing callback functions, i.e blocking APIs should not be called from callback. Users should also assume that interrupts are enabled when in callback context, i.e other interrupt / callbacks can occur when a callback is under execution. User callback implementation should not be very long, since callback execution may block other drivers from executing. Typically it is recommended to set a semaphore or flag when callback happens and do the more involved callback handling in task context.</p>
<p>This callback is typically called by the driver as mentioned below, unless specified otherwise by specific drivers.</p>
<p>In case of display drivers, this callback function will be called when a frame(s) is/are completed displayed. Then the application can dequeue the displayed buffer back from the driver.</p>
<p>In case of capture drivers, this callback function will be called when a frame(s) is/are captured. Then the application can dequeue the captured buffer back from the driver.</p>
<p>In case of M2M drivers, this callback function will be called when a request from the application is completed by the driver. Then the application can dequeue the completed request buffers back from the driver.</p>
<p>In case of control drivers, callbacks are typically not used since mostly FVID2 APIs implemented by control drivers are of blocking nature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[OUT] FVID2 handle for which the callback has occurred. </td></tr>
    <tr><td class="paramname">appData</td><td>[OUT] Application data provided to the driver at the time of <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1b6ddf776c756c47b7a6adcda5d2dc29" title="Creates the driver identified by the driver ID. ">Fvid2_create()</a>. </td></tr>
    <tr><td class="paramname">reserved</td><td>[OUT] For future use. Set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaecfc459d02a9c452b421806231c74137"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Int32(* Fvid2_ErrCbFxn) (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, Ptr appData, Ptr errList, Ptr reserved)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FVID2 error callback function prototype. </p>
<p>Error callback is called by driver when it encounters a error during processing of frames in its internal queue.</p>
<p>When user submits frames to the driver it does minimal error checks and stores the the frames in its internal queues. In case of any error at this point the FVID2 API will simply return error and error callback will not be called.</p>
<p>The driver will later (depending on how its request queue is full) process these frames submitted by the user. If driver finds any error in either the input frame information or hardware itself then it will call this error callback to notify the user about this error. As part of the callback information it also returns the frames or request for which error happened so that user can take appropriate action.</p>
<p>Users should apply same rules as that of Fvid2_CbFxn when implementing error callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[OUT] FVID2 handle for which the callback has occurred. </td></tr>
    <tr><td class="paramname">appData</td><td>[OUT] Application data provided to the driver at the time of <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1b6ddf776c756c47b7a6adcda5d2dc29" title="Creates the driver identified by the driver ID. ">Fvid2_create()</a>. </td></tr>
    <tr><td class="paramname">errList</td><td>[OUT] Pointer to a valid framelist (<a class="el" href="struct_fvid2___frame_list.html" title="FVID2 frame buffer list used to exchange multiple FVID2 frames in a single driver call...">Fvid2_FrameList</a>) in case of capture and display drivers or a pointer to a valid processlist (<a class="el" href="struct_fvid2___process_list.html" title="FVID2 process list containing frame list&#39;s used to exchange multiple input/output buffers in M2M (mem...">Fvid2_ProcessList</a>) in case of M2M drivers. The driver copies the aborted/error frames in this frame list or process list. </td></tr>
    <tr><td class="paramname">reserved</td><td>[OUT] For future use. Set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2f6d55ca4de8dc2972f6b0989be0897"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Int32(* Fvid2_SubFrameCbFxn) (<a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> handle, <a class="el" href="struct_fvid2___frame.html">Fvid2_Frame</a> *subFrame)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FVID2 callback that is called by subframe mode Capture driver. </p>
<p>This callback is called for every subframe of frame that is captured. This function is used by Capture Driver and not meant for M2M drivers.</p>
<p>Users should apply same rules as that of Fvid2_CbFxn when implementing subframe callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[OUT] FVID2 handle for which this callback happened. </td></tr>
    <tr><td class="paramname">subFrameInfo</td><td>[OUT] SubFrame information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabd0b991cddc848f77a78b0d652a1847f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 Fvid2_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr&#160;</td>
          <td class="paramname"><em>cmdArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr&#160;</td>
          <td class="paramname"><em>cmdStatusArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send control commands (IOCTLs) to the driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call.</td></tr>
    <tr><td class="paramname">cmd</td><td>[IN] IOCTL command. The type of command supported is defined by the specific driver.</td></tr>
    <tr><td class="paramname">cmdArgs</td><td>[IN] Pointer to the command argument structure. The type of the structure is defined by the specific driver for each of the supported IOCTL. This parameter could be NULL depending on whether the actual driver forces it or not.</td></tr>
    <tr><td class="paramname">cmdStatusArgs</td><td>[OUT] Pointer to status argument structure where the driver returns any status information. The type of the structure is defined by the specific driver for each of the supported IOCTL. This parameter could be NULL depending on whether the actual driver forces it or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b6ddf776c756c47b7a6adcda5d2dc29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a> Fvid2_create </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>drvId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>instanceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr&#160;</td>
          <td class="paramname"><em>createArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr&#160;</td>
          <td class="paramname"><em>createStatusArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_fvid2___cb_params.html">Fvid2_CbParams</a> *&#160;</td>
          <td class="paramname"><em>cbParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the driver identified by the driver ID. </p>
<p>This will allocate HW and/or SW resources and return a Fvid2_Handle for this driver. This handle will be used for subsequent FVID2 API calls</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drvId</td><td>[IN] Driver to open. Driver ID is driver specific.</td></tr>
    <tr><td class="paramname">instanceId</td><td>[IN] Instance of the driver to open and is used to differentiate multiple instance support on a single driver. Instance ID is driver specific.</td></tr>
    <tr><td class="paramname">createArgs</td><td>[IN] Pointer to the create argument structure. The type of the structure is defined by the specific driver. This parameter could be NULL depending on whether the actual driver forces it or not.</td></tr>
    <tr><td class="paramname">createStatusArgs</td><td>[OUT] Pointer to status argument structure where the driver returns any status information. The type of the structure is defined by the specific driver. This parameter could be NULL depending on whether the actual driver forces it or not.</td></tr>
    <tr><td class="paramname">cbParams</td><td>[IN] Application callback parameters. This parameter could be NULL depending on whether the actual driver forces it or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-NULL Fvid2_Handle object pointer on success else returns NULL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8a3b2aa6dea4ba11e8bfbf888770a64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 Fvid2_deInit </td>
          <td>(</td>
          <td class="paramtype">Ptr&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FVID2 deinit function. </p>
<p>Uninitializes the FVID2 layer and should be called during system shutdown. Should not be called if <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1da9c9b598dfc36350c1afb0af1cba45" title="FVID2 init function. ">Fvid2_init()</a> is not called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>[IN] Not used currently. Set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9da431a59e7ced66bead6ea6ec27fc7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 Fvid2_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr&#160;</td>
          <td class="paramname"><em>deleteArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a previously created FVID2 driver handle. </p>
<p>This free's the HW/SW resources allocated during create</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call.</td></tr>
    <tr><td class="paramname">deleteArgs</td><td>[IN] Pointer to the delete argument structure. The type of the structure is defined by the specific driver. This parameter could be NULL depending on whether the actual driver forces it or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga895bfc7dfdc1564829ab9e92afd89b56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 Fvid2_dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *&#160;</td>
          <td class="paramname"><em>frameList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application calls Fvid2_dequeue to request the video device driver to give ownership of a video buffer. </p>
<ul>
<li>This is used in capture/display drivers.</li>
<li>This is a non-blocking API if timeout is FVID2_TIMEOUT_NONE and could be called by task and ISR context unless the specific driver restricts from doing so.</li>
<li>This is blocking API if timeout is FVID2_TIMEOUT_FOREVER if supported by specific driver implementation.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call. </td></tr>
    <tr><td class="paramname">frameList</td><td>[OUT] Pointer to the frame list structure where the dequeued frame pointer will be stored. </td></tr>
    <tr><td class="paramname">streamId</td><td>[IN] Stream ID from where frames should be dequeued. This is used in drivers where it could support multiple streams for the same handle. Otherwise this should be set to zero. </td></tr>
    <tr><td class="paramname">timeout</td><td>[IN] FVID2 timeout in units of OS ticks. This will determine the timeout value till the driver will block for a free or completed buffer is available. For non-blocking drivers this parameter might be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga995a3f6e9e95152e1a4dfd4525761eb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 Fvid2_getFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fvid2___format.html">Fvid2_Format</a> *&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An application calls Fvid2_getFormat to request the video device driver to get the current format for a given channel. This function should be called from task context only and should not be called from ISR context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call. </td></tr>
    <tr><td class="paramname">fmt</td><td>[OUT] Pointer to the FVID2 format structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaba44221afaaa45005ef0e7baf4c8c2ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 Fvid2_getProcessedFrames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fvid2___process_list.html">Fvid2_ProcessList</a> *&#160;</td>
          <td class="paramname"><em>processList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application calls Fvid2_getProcessedFrames to request the video device driver to give ownership of a video buffer. </p>
<p>This API is very similar to the Fvid2_dequeue API except that this is used in M2M drivers only.</p><ul>
<li>This is a non-blocking API if timeout is FVID2_TIMEOUT_NONE and could be called by task and ISR context unless the specific driver restricts from doing so.</li>
<li>This is blocking API if timeout is FVID2_TIMEOUT_FOREVER if supported by specific driver implementation.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call. </td></tr>
    <tr><td class="paramname">processList</td><td>[OUT] Pointer to the process list structure where the driver will copy the references to the dequeued FVID2 frame lists and frames. </td></tr>
    <tr><td class="paramname">timeout</td><td>[IN] FVID2 timeout. This will determine the timeout value till the driver will block for a free or completed buffer is available. For non-blocking drivers this parameter might be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0fe8881d838a04fc52d0339886b68874"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 Fvid2_getProcessedRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *&#160;</td>
          <td class="paramname"><em>inFrameList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *&#160;</td>
          <td class="paramname"><em>outFrameList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application calls Fvid2_getProcessedRequest to get the processed request back from the driver and thus to get the ownership of request back from the driver. </p>
<ul>
<li>This is a non-blocking API if timeout is FVID2_TIMEOUT_NONE and could be called by task and ISR context unless the specific driver restricts from doing so.</li>
<li>This is blocking API if timeout is FVID2_TIMEOUT_FOREVER if supported by specific driver implementation.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call. </td></tr>
    <tr><td class="paramname">inFrameList</td><td>[OUT] Pointer to frame list in which input frames with different stream ids will be returned by the driver. </td></tr>
    <tr><td class="paramname">outFrameList</td><td>[OUT] Pointer to frame list in which output frames with different stream ids will be returned by the driver. </td></tr>
    <tr><td class="paramname">timeout</td><td>[IN] FVID2 timeout. This will determine the timeout value till the driver will block for a free or completed buffer is available. For non-blocking drivers this parameter might be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga072c6a6771e5a9bfd6edbec4a9a60bb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 Fvid2_getVersionNumber </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga84aceedf7244d24c40d051cb9f4a3c67" title="Get the version string for FVID2 interface. ">Fvid2_getVersionString()</a> except it returns the version in UInt32 form. </p>
<p>Example, v1.0.1.17 will be 0x01000117</p>
<dl class="section return"><dt>Returns</dt><dd>FVID2 version number. </dd></dl>

</div>
</div>
<a class="anchor" id="ga84aceedf7244d24c40d051cb9f4a3c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Char* Fvid2_getVersionString </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the version string for FVID2 interface. </p>
<p>This is the version number for the FVID2 interface. This function can be called prior to <a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga1da9c9b598dfc36350c1afb0af1cba45" title="FVID2 init function. ">Fvid2_init()</a> to get the version number.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to FVID2 version string. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1da9c9b598dfc36350c1afb0af1cba45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 Fvid2_init </td>
          <td>(</td>
          <td class="paramtype">Ptr&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FVID2 init function. </p>
<p>Initializes the FVID2 layer. This function should be called before calling any of FVID2 API's and should be called only once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>[IN] Not used currently. Set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gae97f8ae2198d5891ee8511277f40675f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 Fvid2_processFrames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fvid2___process_list.html">Fvid2_ProcessList</a> *&#160;</td>
          <td class="paramname"><em>processList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application calls Fvid2_processFrames to submit a video buffer to the video device driver. </p>
<p>This API is very similar to the Fvid2_queue API except that this is used in M2M drivers only.</p><ul>
<li>This function could be called from task or ISR context unless the specific driver restricts from doing so.</li>
<li>This is a non-blocking API unless the specific driver restricts from doing so.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call. </td></tr>
    <tr><td class="paramname">processList</td><td>[IN] Pointer to the process list structure containing the information about the FVID2 frame lists and frames that has to be queued to the driver for processing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b905328ed0b067fdc73b39cdbfeec1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 Fvid2_processRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *&#160;</td>
          <td class="paramname"><em>inFrameList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *&#160;</td>
          <td class="paramname"><em>outFrameList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application calls Fvid2_processRequest to submit a video buffer to the video device driver. </p>
<p>This API is used for submitting a single channel video processing request to the video device driver. It uses framelist to submit multiple frames of different stream ids of the same request.</p>
<ul>
<li>This function could be called from task or ISR context unless the specific driver restricts from doing so.</li>
<li>This is a non-blocking API unless the specific driver restricts from doing so.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call. </td></tr>
    <tr><td class="paramname">inFrameList</td><td>[IN] Pointer to the array of input frames with different stream ids. </td></tr>
    <tr><td class="paramname">outFrameList</td><td>[IN] Pointer to the array of output frames with different stream ids</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga546aa58a2d6444eaa6e17bb065cef401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 Fvid2_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fvid2___frame_list.html">Fvid2_FrameList</a> *&#160;</td>
          <td class="paramname"><em>frameList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>streamId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application calls Fvid2_queue to submit a video buffer to the video device driver. </p>
<ul>
<li>This is used in capture/display drivers.</li>
<li>This function could be called from task or ISR context unless the specific driver restricts from doing so.</li>
<li>This is a non-blocking API unless the specific driver restricts from doing so.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call. </td></tr>
    <tr><td class="paramname">frameList</td><td>[IN] Pointer to the frame list structure containing the information about the FVID2 frames that has to be queued in the driver. </td></tr>
    <tr><td class="paramname">streamId</td><td>[IN] Stream ID to which the frames should be queued This is used in drivers where they could support multiple streams for the same handle. Otherwise this should be set to zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga050dbd9b1eebd6ec0ba63178ea17eca5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 Fvid2_setFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_fvid2___format.html">Fvid2_Format</a> *&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An application calls Fvid2_setFormat to request the video device driver to set the format for a given channel. This function should be called from task context only and should not be called from ISR context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call. </td></tr>
    <tr><td class="paramname">fmt</td><td>[IN] Pointer to the FVID2 format structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0345d6a47c9b678cccde6a8b4c8660cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 Fvid2_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr&#160;</td>
          <td class="paramname"><em>cmdArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An application calls Fvid2_start to request the video device driver to start the video display or capture operation. This function should be called from task context only and should not be called from ISR context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call. </td></tr>
    <tr><td class="paramname">cmdArgs</td><td>[IN] Pointer to the start argument structure. The type of the structure is defined by the specific driver. This parameter could be NULL depending on whether the actual driver forces it or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaee331b26ea04f78c1d57aaedfd8fa39f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Int32 Fvid2_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___b_s_p___d_r_v___f_v_i_d2___a_p_i.html#ga70385ba792f5870018ee2f3ce413f3c1">Fvid2_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr&#160;</td>
          <td class="paramname"><em>cmdArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An application calls Fvid2_stop to request the video device driver to stop the video display or capture operation. This function should be called from task context only and should not be called from ISR context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] FVID2 handle returned by create call. </td></tr>
    <tr><td class="paramname">cmdArgs</td><td>[IN] Pointer to the stop argument structure. The type of the structure is defined by the specific driver. This parameter could be NULL depending on whether the actual driver forces it or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FVID2_SOK on success, else appropriate FVID2 error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dea4a8dfac43f4c151775a2a7af4cab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fvid2CbParams_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_fvid2___cb_params.html">Fvid2_CbParams</a> *&#160;</td>
          <td class="paramname"><em>cbPrms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_fvid2___cb_params.html" title="FVID2 callback parameters that are setup during Fvid2_create(). ">Fvid2_CbParams</a> structure init function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbPrms</td><td>[IN] Pointer to <a class="el" href="struct_fvid2___cb_params.html" title="FVID2 callback parameters that are setup during Fvid2_create(). ">Fvid2_CbParams</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga903495c2de873a3f0522596acf87bb21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Fvid2ProcessList_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_fvid2___process_list.html">Fvid2_ProcessList</a> *&#160;</td>
          <td class="paramname"><em>pList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_fvid2___process_list.html" title="FVID2 process list containing frame list&#39;s used to exchange multiple input/output buffers in M2M (mem...">Fvid2_ProcessList</a> structure init function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pList</td><td>[IN] Pointer to <a class="el" href="struct_fvid2___process_list.html" title="FVID2 process list containing frame list&#39;s used to exchange multiple input/output buffers in M2M (mem...">Fvid2_ProcessList</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2019, Texas Instruments Incorporated</small>
</body>
</html>
