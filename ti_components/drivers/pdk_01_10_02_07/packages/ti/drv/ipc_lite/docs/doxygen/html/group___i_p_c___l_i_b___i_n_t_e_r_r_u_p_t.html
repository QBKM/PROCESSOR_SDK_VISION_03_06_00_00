<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IPC LIB Interrupt Module</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IPC LIB Interrupt Module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ipclib__interrupt_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipclib__interrupt_8h.html">ipclib_interrupt.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ipc_lib___interrupt_init_prms.html">IpcLib_InterruptInitPrms</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure holds parameters required to initialize ipclib interrupt module.  <a href="struct_ipc_lib___interrupt_init_prms.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga76232b4a528961240ba72aff40bdc19b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga76232b4a528961240ba72aff40bdc19b">IPCLIB_MAX_EVENTS</a>&#160;&#160;&#160;(32U)</td></tr>
<tr class="memdesc:ga76232b4a528961240ba72aff40bdc19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines number of events supported per interrupt.  <a href="#ga76232b4a528961240ba72aff40bdc19b">More...</a><br /></td></tr>
<tr class="separator:ga76232b4a528961240ba72aff40bdc19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9a7e0a674572584178e8c67b99c5789"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9a7e0a674572584178e8c67b99c5789"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gad9a7e0a674572584178e8c67b99c5789">IPCLIB_INVALID_INFO</a>&#160;&#160;&#160;(0xFFFFFFFFU)</td></tr>
<tr class="memdesc:gad9a7e0a674572584178e8c67b99c5789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines invalid entry. <br /></td></tr>
<tr class="separator:gad9a7e0a674572584178e8c67b99c5789"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1a3ff6ccc45f85ac891db15221c2a1e5"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1a3ff6ccc45f85ac891db15221c2a1e5">IpcLib_InterruptCallback</a>) (uint32_t remoteProcId, uint32_t eventId, uint32_t payload, void *arg, int32_t status)</td></tr>
<tr class="memdesc:ga1a3ff6ccc45f85ac891db15221c2a1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is interrupt callback fxn ptr to be stored in callback table.  <a href="#ga1a3ff6ccc45f85ac891db15221c2a1e5">More...</a><br /></td></tr>
<tr class="separator:ga1a3ff6ccc45f85ac891db15221c2a1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1faaaf38a43c0687d726d9cf891dc7ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1faaaf38a43c0687d726d9cf891dc7ea">IpcLib_InterruptReturnCodes</a> { <br />
&#160;&#160;<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaa0b648fdb9b503e24154a5ba31e220f0f">IPCLIB_SOK</a> = 0, 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaad736e88b0b757d1f2dcd2d70d591921b">IPCLIB_EFAIL</a> = -((int32_t) 1), 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaa490322635c240c650b2bb07e88050591">IPCLIB_EBADARGS</a> = -((int32_t) 2), 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaab603000c4c77a1dd7afe0b916996bcbb">IPCLIB_EALREADYREGISTERED</a> = -((int32_t) 3), 
<br />
&#160;&#160;<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaa03a23fcf5adefd12875ce283acf2866a">IPCLIB_ESENDFAILED</a> = -((int32_t) 4), 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaa8c16731aaeceecc94358d64f05fd0f67">IPCLIB_EINVALIDPROCID</a> = -((int32_t) 5), 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaad9b99e7524598c8b00c031b516775177">IPCLIB_ENOTSUPPORTED</a> = -((int32_t) 6), 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaac213a3f5cf61005ff4deef508b8697ff">IPCLIB_ETIMEOUT</a> = -((int32_t) 8), 
<br />
&#160;&#160;<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaa6ea414565fbf0981ccaf501b560c7f74">IPCLIB_FORCE32BITS</a> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="memdesc:ga1faaaf38a43c0687d726d9cf891dc7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the error codes that ipclib returns to the caller.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1faaaf38a43c0687d726d9cf891dc7ea">More...</a><br /></td></tr>
<tr class="separator:ga1faaaf38a43c0687d726d9cf891dc7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaead5330a843036fea015bec66eca4598"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gaead5330a843036fea015bec66eca4598">IpcLib_interruptInit</a> (const <a class="el" href="struct_ipc_lib___interrupt_init_prms.html">IpcLib_InterruptInitPrms</a> *pPrm)</td></tr>
<tr class="memdesc:gaead5330a843036fea015bec66eca4598"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to initialize ipc interrupt module.  <a href="#gaead5330a843036fea015bec66eca4598">More...</a><br /></td></tr>
<tr class="separator:gaead5330a843036fea015bec66eca4598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19965b4013dec9d85b143f55bac2f89a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga19965b4013dec9d85b143f55bac2f89a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga19965b4013dec9d85b143f55bac2f89a">IpcLib_interruptDeInit</a> (void)</td></tr>
<tr class="memdesc:ga19965b4013dec9d85b143f55bac2f89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to de-initialize ipc interrupt module. <br /></td></tr>
<tr class="separator:ga19965b4013dec9d85b143f55bac2f89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08681696e43b54998d9583940b8c345c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga08681696e43b54998d9583940b8c345c">IpcLib_interruptSetDefaultInitPrm</a> (<a class="el" href="struct_ipc_lib___interrupt_init_prms.html">IpcLib_InterruptInitPrms</a> *pPrm)</td></tr>
<tr class="memdesc:ga08681696e43b54998d9583940b8c345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to set default params.  <a href="#ga08681696e43b54998d9583940b8c345c">More...</a><br /></td></tr>
<tr class="separator:ga08681696e43b54998d9583940b8c345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44cacfc064a76119ca77a8f060e44b22"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga44cacfc064a76119ca77a8f060e44b22">IpcLib_interruptRegisterEvent</a> (uint32_t remoteProcId, uint32_t eventId, <a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1a3ff6ccc45f85ac891db15221c2a1e5">IpcLib_InterruptCallback</a> fxn, void *arg)</td></tr>
<tr class="memdesc:ga44cacfc064a76119ca77a8f060e44b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to registers interrupt callback function.  <a href="#ga44cacfc064a76119ca77a8f060e44b22">More...</a><br /></td></tr>
<tr class="separator:ga44cacfc064a76119ca77a8f060e44b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae36650b589336a8f815135c1d3b6e11a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gae36650b589336a8f815135c1d3b6e11a">IpcLib_interruptUnregisterEvent</a> (uint32_t remoteProcId, uint32_t eventId)</td></tr>
<tr class="memdesc:gae36650b589336a8f815135c1d3b6e11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to unregisters interrupt callback function.  <a href="#gae36650b589336a8f815135c1d3b6e11a">More...</a><br /></td></tr>
<tr class="separator:gae36650b589336a8f815135c1d3b6e11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab42305b3a908062ad67fde4ee42e9947"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gab42305b3a908062ad67fde4ee42e9947">IpcLib_interruptSendEvent</a> (uint32_t remoteProcId, uint32_t eventId, uint32_t payload, uint32_t waitClear)</td></tr>
<tr class="memdesc:gab42305b3a908062ad67fde4ee42e9947"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to send 32 bit value to remote core and interrupt remote processor.  <a href="#gab42305b3a908062ad67fde4ee42e9947">More...</a><br /></td></tr>
<tr class="separator:gab42305b3a908062ad67fde4ee42e9947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2202d984e7452f7c1f0ae18ca1debd18"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga2202d984e7452f7c1f0ae18ca1debd18">IpcLib_interruptEnable</a> (uint32_t remoteProcId)</td></tr>
<tr class="memdesc:ga2202d984e7452f7c1f0ae18ca1debd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to enable mailboxes.  <a href="#ga2202d984e7452f7c1f0ae18ca1debd18">More...</a><br /></td></tr>
<tr class="separator:ga2202d984e7452f7c1f0ae18ca1debd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a677fd042f2bc671ee0973ffa132135"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1a677fd042f2bc671ee0973ffa132135">IpcLib_interruptDisable</a> (uint32_t remoteProcId)</td></tr>
<tr class="memdesc:ga1a677fd042f2bc671ee0973ffa132135"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to Disable mailboxes.  <a href="#ga1a677fd042f2bc671ee0973ffa132135">More...</a><br /></td></tr>
<tr class="separator:ga1a677fd042f2bc671ee0973ffa132135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40e87ecf9ba73768d5222418c2f5d412"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga40e87ecf9ba73768d5222418c2f5d412">IpcLib_interruptGetSelfProcId</a> (void)</td></tr>
<tr class="memdesc:ga40e87ecf9ba73768d5222418c2f5d412"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns procId of executing processor.  <a href="#ga40e87ecf9ba73768d5222418c2f5d412">More...</a><br /></td></tr>
<tr class="separator:ga40e87ecf9ba73768d5222418c2f5d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8f3abdc107e79ae469fee8f0ce70f0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga4a8f3abdc107e79ae469fee8f0ce70f0">IpcLib_interruptGetProcId</a> (const char *name)</td></tr>
<tr class="memdesc:ga4a8f3abdc107e79ae469fee8f0ce70f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns procId based on processor name.  <a href="#ga4a8f3abdc107e79ae469fee8f0ce70f0">More...</a><br /></td></tr>
<tr class="separator:ga4a8f3abdc107e79ae469fee8f0ce70f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4576f71cec34450c20f6f88faa9bc03"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gab4576f71cec34450c20f6f88faa9bc03">IpcLib_interruptGetProcName</a> (char *name, uint32_t length, uint32_t id)</td></tr>
<tr class="memdesc:gab4576f71cec34450c20f6f88faa9bc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns proc name based on procId.  <a href="#gab4576f71cec34450c20f6f88faa9bc03">More...</a><br /></td></tr>
<tr class="separator:gab4576f71cec34450c20f6f88faa9bc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga76232b4a528961240ba72aff40bdc19b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPCLIB_MAX_EVENTS&#160;&#160;&#160;(32U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines number of events supported per interrupt. </p>
<p>Below are the IPC_LIB module environment requirements which can't be mapped to a particular source ID.DES_ID : DOX_DES_TAG(DES_IPC_LITE_001) REQ_ID : DOX_REQ_TAG(PDK-1414) DOX_REQ_TAG(PDK-1430) DOX_REQ_TAG(PDK-1480) DOX_REQ_TAG(PDK-1422) DOX_REQ_TAG(PDK-1424) DOX_REQ_TAG(PDK-1420) DOX_REQ_TAG(PDK-1412) DOX_REQ_TAG(PDK-1479) Below are the IPC_LIB module environment requirements which can't be mapped to this driver.DES_ID : DOX_DES_TAG(DES_IPC_LITE_002) REQ_ID : DOX_REQ_TAG(PDK-1481) DOX_REQ_TAG(PDK-1586) </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga1a3ff6ccc45f85ac891db15221c2a1e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* IpcLib_InterruptCallback) (uint32_t remoteProcId, uint32_t eventId, uint32_t payload, void *arg, int32_t status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is interrupt callback fxn ptr to be stored in callback table. </p>
<p>Application should define and register a callback function of type IpcLib_InterruptCallback</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remoteProcId</td><td>Processor id which interrupted current processor </td></tr>
    <tr><td class="paramname">eventId</td><td>Event id out of IPCLIB_MAX_EVENTS </td></tr>
    <tr><td class="paramname">payload</td><td>Message that remote processor wanted to convey </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to the callback function </td></tr>
    <tr><td class="paramname">status</td><td>ISR status IPCLIB_SOK indicates payload is complete and callback ISR execeuted successfully. Any other return code indicates ISR failed to retrieve message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga1faaaf38a43c0687d726d9cf891dc7ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1faaaf38a43c0687d726d9cf891dc7ea">IpcLib_InterruptReturnCodes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the error codes that ipclib returns to the caller. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1faaaf38a43c0687d726d9cf891dc7eaa0b648fdb9b503e24154a5ba31e220f0f"></a>IPCLIB_SOK&#160;</td><td class="fielddoc">
<p>Return success </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1faaaf38a43c0687d726d9cf891dc7eaad736e88b0b757d1f2dcd2d70d591921b"></a>IPCLIB_EFAIL&#160;</td><td class="fielddoc">
<p>send interrupt failed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1faaaf38a43c0687d726d9cf891dc7eaa490322635c240c650b2bb07e88050591"></a>IPCLIB_EBADARGS&#160;</td><td class="fielddoc">
<p>Wrong parameters passed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1faaaf38a43c0687d726d9cf891dc7eaab603000c4c77a1dd7afe0b916996bcbb"></a>IPCLIB_EALREADYREGISTERED&#160;</td><td class="fielddoc">
<p>Call back is already registered for the event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1faaaf38a43c0687d726d9cf891dc7eaa03a23fcf5adefd12875ce283acf2866a"></a>IPCLIB_ESENDFAILED&#160;</td><td class="fielddoc">
<p>Send interrupt failed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1faaaf38a43c0687d726d9cf891dc7eaa8c16731aaeceecc94358d64f05fd0f67"></a>IPCLIB_EINVALIDPROCID&#160;</td><td class="fielddoc">
<p>Send interrupt failed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1faaaf38a43c0687d726d9cf891dc7eaad9b99e7524598c8b00c031b516775177"></a>IPCLIB_ENOTSUPPORTED&#160;</td><td class="fielddoc">
<p>Mailbox communication not supported </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1faaaf38a43c0687d726d9cf891dc7eaac213a3f5cf61005ff4deef508b8697ff"></a>IPCLIB_ETIMEOUT&#160;</td><td class="fielddoc">
<p>Incomplete message being delivered </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1faaaf38a43c0687d726d9cf891dc7eaa6ea414565fbf0981ccaf501b560c7f74"></a>IPCLIB_FORCE32BITS&#160;</td><td class="fielddoc">
<p>To make sure enum is 32 bits </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1a677fd042f2bc671ee0973ffa132135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t IpcLib_interruptDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>remoteProcId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to Disable mailboxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remoteProcId</td><td>remote processor id for which mailboxes need to be disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status codes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is valid only for Tdaxx </dd></dl>

</div>
</div>
<a class="anchor" id="ga2202d984e7452f7c1f0ae18ca1debd18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t IpcLib_interruptEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>remoteProcId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to enable mailboxes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remoteProcId</td><td>Remote processor id for which mailboxes need to be enabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status codes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is valid only for Tdaxx </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a8f3abdc107e79ae469fee8f0ce70f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IpcLib_interruptGetProcId </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns procId based on processor name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>output - proc name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>procId</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This internal fucntion is valid only for Tdaxx </dd></dl>

</div>
</div>
<a class="anchor" id="gab4576f71cec34450c20f6f88faa9bc03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t IpcLib_interruptGetProcName </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns proc name based on procId. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>- OUT param - name of processor </td></tr>
    <tr><td class="paramname">length</td><td>- max character length for name </td></tr>
    <tr><td class="paramname">id</td><td>- proc id for which name needs to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status codes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This internal fucntion is valid only for Tdaxx </dd></dl>

</div>
</div>
<a class="anchor" id="ga40e87ecf9ba73768d5222418c2f5d412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t IpcLib_interruptGetSelfProcId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns procId of executing processor. </p>
<dl class="section return"><dt>Returns</dt><dd>procId</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This internal fucntion is valid only for Tdaxx </dd></dl>

</div>
</div>
<a class="anchor" id="gaead5330a843036fea015bec66eca4598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t IpcLib_interruptInit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ipc_lib___interrupt_init_prms.html">IpcLib_InterruptInitPrms</a> *&#160;</td>
          <td class="paramname"><em>pPrm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to initialize ipc interrupt module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPrm</td><td>Initialization parameters for ipclib interrupt module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of initilization </dd></dl>

</div>
</div>
<a class="anchor" id="ga44cacfc064a76119ca77a8f060e44b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t IpcLib_interruptRegisterEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>remoteProcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1a3ff6ccc45f85ac891db15221c2a1e5">IpcLib_InterruptCallback</a>&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to registers interrupt callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remoteProcId</td><td>Remote processor id for which event is being registered (remote processor from which interrupt is expected) </td></tr>
    <tr><td class="paramname">eventId</td><td>Event number less than maximum supported events </td></tr>
    <tr><td class="paramname">fxn</td><td>Callback function to be registered </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status codes </dd></dl>

</div>
</div>
<a class="anchor" id="gab42305b3a908062ad67fde4ee42e9947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t IpcLib_interruptSendEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>remoteProcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>waitClear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to send 32 bit value to remote core and interrupt remote processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remoteProcId</td><td>Remote processor id which needs to be interrupted </td></tr>
    <tr><td class="paramname">eventId</td><td>Event number for which interrupt is to be sent </td></tr>
    <tr><td class="paramname">payload</td><td>Message value that needs to be sent accross </td></tr>
    <tr><td class="paramname">waitClear</td><td>Flag which ensures interrupt is delivered / processed by intented remote core. Setting this TRUE guarantees tx message to be written in mailbox.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status codes </dd></dl>

</div>
</div>
<a class="anchor" id="ga08681696e43b54998d9583940b8c345c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IpcLib_interruptSetDefaultInitPrm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ipc_lib___interrupt_init_prms.html">IpcLib_InterruptInitPrms</a> *&#160;</td>
          <td class="paramname"><em>pPrm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to set default params. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPrm</td><td>initialization parameters for ipclib interrupt module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gae36650b589336a8f815135c1d3b6e11a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t IpcLib_interruptUnregisterEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>remoteProcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to unregisters interrupt callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remoteProcId</td><td>Remote processor id for which event is being unregistered </td></tr>
    <tr><td class="paramname">eventId</td><td>Event number less than maximum supported events</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status codes </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2019, Texas Instruments Incorporated</small>
</body>
</html>
