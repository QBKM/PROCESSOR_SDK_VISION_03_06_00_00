<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ipclib_interrupt.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ipclib_interrupt.h File Reference<div class="ingroups"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html">IPC LIB Interrupt Module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ipc_lib___interrupt_init_prms.html">IpcLib_InterruptInitPrms</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure holds parameters required to initialize ipclib interrupt module.  <a href="struct_ipc_lib___interrupt_init_prms.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga76232b4a528961240ba72aff40bdc19b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga76232b4a528961240ba72aff40bdc19b">IPCLIB_MAX_EVENTS</a>&#160;&#160;&#160;(32U)</td></tr>
<tr class="memdesc:ga76232b4a528961240ba72aff40bdc19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines number of events supported per interrupt.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga76232b4a528961240ba72aff40bdc19b">More...</a><br /></td></tr>
<tr class="separator:ga76232b4a528961240ba72aff40bdc19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9a7e0a674572584178e8c67b99c5789"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9a7e0a674572584178e8c67b99c5789"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gad9a7e0a674572584178e8c67b99c5789">IPCLIB_INVALID_INFO</a>&#160;&#160;&#160;(0xFFFFFFFFU)</td></tr>
<tr class="memdesc:gad9a7e0a674572584178e8c67b99c5789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines invalid entry. <br /></td></tr>
<tr class="separator:gad9a7e0a674572584178e8c67b99c5789"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1a3ff6ccc45f85ac891db15221c2a1e5"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1a3ff6ccc45f85ac891db15221c2a1e5">IpcLib_InterruptCallback</a>) (uint32_t remoteProcId, uint32_t eventId, uint32_t payload, void *arg, int32_t status)</td></tr>
<tr class="memdesc:ga1a3ff6ccc45f85ac891db15221c2a1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is interrupt callback fxn ptr to be stored in callback table.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1a3ff6ccc45f85ac891db15221c2a1e5">More...</a><br /></td></tr>
<tr class="separator:ga1a3ff6ccc45f85ac891db15221c2a1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1faaaf38a43c0687d726d9cf891dc7ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1faaaf38a43c0687d726d9cf891dc7ea">IpcLib_InterruptReturnCodes</a> { <br />
&#160;&#160;<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaa0b648fdb9b503e24154a5ba31e220f0f">IPCLIB_SOK</a> = 0, 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaad736e88b0b757d1f2dcd2d70d591921b">IPCLIB_EFAIL</a> = -((int32_t) 1), 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaa490322635c240c650b2bb07e88050591">IPCLIB_EBADARGS</a> = -((int32_t) 2), 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaab603000c4c77a1dd7afe0b916996bcbb">IPCLIB_EALREADYREGISTERED</a> = -((int32_t) 3), 
<br />
&#160;&#160;<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaa03a23fcf5adefd12875ce283acf2866a">IPCLIB_ESENDFAILED</a> = -((int32_t) 4), 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaa8c16731aaeceecc94358d64f05fd0f67">IPCLIB_EINVALIDPROCID</a> = -((int32_t) 5), 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaad9b99e7524598c8b00c031b516775177">IPCLIB_ENOTSUPPORTED</a> = -((int32_t) 6), 
<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaac213a3f5cf61005ff4deef508b8697ff">IPCLIB_ETIMEOUT</a> = -((int32_t) 8), 
<br />
&#160;&#160;<a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gga1faaaf38a43c0687d726d9cf891dc7eaa6ea414565fbf0981ccaf501b560c7f74">IPCLIB_FORCE32BITS</a> = 0x7FFFFFFF
<br />
 }</td></tr>
<tr class="memdesc:ga1faaaf38a43c0687d726d9cf891dc7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the error codes that ipclib returns to the caller.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1faaaf38a43c0687d726d9cf891dc7ea">More...</a><br /></td></tr>
<tr class="separator:ga1faaaf38a43c0687d726d9cf891dc7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaead5330a843036fea015bec66eca4598"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gaead5330a843036fea015bec66eca4598">IpcLib_interruptInit</a> (const <a class="el" href="struct_ipc_lib___interrupt_init_prms.html">IpcLib_InterruptInitPrms</a> *pPrm)</td></tr>
<tr class="memdesc:gaead5330a843036fea015bec66eca4598"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to initialize ipc interrupt module.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gaead5330a843036fea015bec66eca4598">More...</a><br /></td></tr>
<tr class="separator:gaead5330a843036fea015bec66eca4598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19965b4013dec9d85b143f55bac2f89a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga19965b4013dec9d85b143f55bac2f89a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga19965b4013dec9d85b143f55bac2f89a">IpcLib_interruptDeInit</a> (void)</td></tr>
<tr class="memdesc:ga19965b4013dec9d85b143f55bac2f89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to de-initialize ipc interrupt module. <br /></td></tr>
<tr class="separator:ga19965b4013dec9d85b143f55bac2f89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08681696e43b54998d9583940b8c345c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga08681696e43b54998d9583940b8c345c">IpcLib_interruptSetDefaultInitPrm</a> (<a class="el" href="struct_ipc_lib___interrupt_init_prms.html">IpcLib_InterruptInitPrms</a> *pPrm)</td></tr>
<tr class="memdesc:ga08681696e43b54998d9583940b8c345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to set default params.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga08681696e43b54998d9583940b8c345c">More...</a><br /></td></tr>
<tr class="separator:ga08681696e43b54998d9583940b8c345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44cacfc064a76119ca77a8f060e44b22"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga44cacfc064a76119ca77a8f060e44b22">IpcLib_interruptRegisterEvent</a> (uint32_t remoteProcId, uint32_t eventId, <a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1a3ff6ccc45f85ac891db15221c2a1e5">IpcLib_InterruptCallback</a> fxn, void *arg)</td></tr>
<tr class="memdesc:ga44cacfc064a76119ca77a8f060e44b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to registers interrupt callback function.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga44cacfc064a76119ca77a8f060e44b22">More...</a><br /></td></tr>
<tr class="separator:ga44cacfc064a76119ca77a8f060e44b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae36650b589336a8f815135c1d3b6e11a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gae36650b589336a8f815135c1d3b6e11a">IpcLib_interruptUnregisterEvent</a> (uint32_t remoteProcId, uint32_t eventId)</td></tr>
<tr class="memdesc:gae36650b589336a8f815135c1d3b6e11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to unregisters interrupt callback function.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gae36650b589336a8f815135c1d3b6e11a">More...</a><br /></td></tr>
<tr class="separator:gae36650b589336a8f815135c1d3b6e11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab42305b3a908062ad67fde4ee42e9947"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gab42305b3a908062ad67fde4ee42e9947">IpcLib_interruptSendEvent</a> (uint32_t remoteProcId, uint32_t eventId, uint32_t payload, uint32_t waitClear)</td></tr>
<tr class="memdesc:gab42305b3a908062ad67fde4ee42e9947"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to send 32 bit value to remote core and interrupt remote processor.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gab42305b3a908062ad67fde4ee42e9947">More...</a><br /></td></tr>
<tr class="separator:gab42305b3a908062ad67fde4ee42e9947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2202d984e7452f7c1f0ae18ca1debd18"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga2202d984e7452f7c1f0ae18ca1debd18">IpcLib_interruptEnable</a> (uint32_t remoteProcId)</td></tr>
<tr class="memdesc:ga2202d984e7452f7c1f0ae18ca1debd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to enable mailboxes.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga2202d984e7452f7c1f0ae18ca1debd18">More...</a><br /></td></tr>
<tr class="separator:ga2202d984e7452f7c1f0ae18ca1debd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a677fd042f2bc671ee0973ffa132135"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1a677fd042f2bc671ee0973ffa132135">IpcLib_interruptDisable</a> (uint32_t remoteProcId)</td></tr>
<tr class="memdesc:ga1a677fd042f2bc671ee0973ffa132135"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to Disable mailboxes.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga1a677fd042f2bc671ee0973ffa132135">More...</a><br /></td></tr>
<tr class="separator:ga1a677fd042f2bc671ee0973ffa132135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40e87ecf9ba73768d5222418c2f5d412"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga40e87ecf9ba73768d5222418c2f5d412">IpcLib_interruptGetSelfProcId</a> (void)</td></tr>
<tr class="memdesc:ga40e87ecf9ba73768d5222418c2f5d412"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns procId of executing processor.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga40e87ecf9ba73768d5222418c2f5d412">More...</a><br /></td></tr>
<tr class="separator:ga40e87ecf9ba73768d5222418c2f5d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8f3abdc107e79ae469fee8f0ce70f0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga4a8f3abdc107e79ae469fee8f0ce70f0">IpcLib_interruptGetProcId</a> (const char *name)</td></tr>
<tr class="memdesc:ga4a8f3abdc107e79ae469fee8f0ce70f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns procId based on processor name.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga4a8f3abdc107e79ae469fee8f0ce70f0">More...</a><br /></td></tr>
<tr class="separator:ga4a8f3abdc107e79ae469fee8f0ce70f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4576f71cec34450c20f6f88faa9bc03"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gab4576f71cec34450c20f6f88faa9bc03">IpcLib_interruptGetProcName</a> (char *name, uint32_t length, uint32_t id)</td></tr>
<tr class="memdesc:gab4576f71cec34450c20f6f88faa9bc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns proc name based on procId.  <a href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gab4576f71cec34450c20f6f88faa9bc03">More...</a><br /></td></tr>
<tr class="separator:gab4576f71cec34450c20f6f88faa9bc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the IpcLib APIs for inter processor communication using ipc interrupt module.</p>
<p>IpcLib interrupt module implementation is as mentioned below</p>
<p>file - ipclib/ipclib_interrupt.c API Implementation common to all platforms</p>
<p>file - ipclib/[$SOC]/ipclib_interrupt[$SOC].c Platform specific implementation of interrupt setup / connection</p>
<p>Ipclib module configuration is as mentioned below</p>
<p>file - ipclib/[$SOC]/ipclib_interrupt[$SOC]ProcCfg.c Platform specific implementation of available processors in the system. IpcLib API and utility functions operate on IpcLib_gProcConfig to get information about processor ids and names</p>
<p>file - ipclib/[$SOC]/ipclib_interrupt[$SOC]MailboxCfg.c Platform specific implementation of mailbox base addresses and mailbox table that is used for N x N bidirectional communication. Each entry in this table indicates mailbox entry that is used for unidirectional comminication from source to destination. Here Source and destinations are indexes to 2D IpcLib_gMailboxConfig</p>
<p>file - ipclib/[$SOC]/ipclib_interrupt[$SOC]XbarCfg.c Platform specific implementation of local interrupt numbers and their connections. This can change based on platform</p>
<p>Using IpcLib in application Receiver's sequence</p>
<ol type="1">
<li><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga08681696e43b54998d9583940b8c345c" title="This API is used to set default params. ">IpcLib_interruptSetDefaultInitPrm()</a> (optional but advised)</li>
<li>Change params as required</li>
<li><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gaead5330a843036fea015bec66eca4598" title="This API is used to initialize ipc interrupt module. ">IpcLib_interruptInit()</a> - with valid params</li>
<li><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga44cacfc064a76119ca77a8f060e44b22" title="This API is used to registers interrupt callback function. ">IpcLib_interruptRegisterEvent()</a> - with valid callback function</li>
</ol>
<p>Sender's sequence</p>
<ol type="1">
<li><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#ga08681696e43b54998d9583940b8c345c" title="This API is used to set default params. ">IpcLib_interruptSetDefaultInitPrm()</a> (optional but advised)</li>
<li>Change params as required</li>
<li><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gaead5330a843036fea015bec66eca4598" title="This API is used to initialize ipc interrupt module. ">IpcLib_interruptInit()</a> - with valid params</li>
<li><a class="el" href="group___i_p_c___l_i_b___i_n_t_e_r_r_u_p_t.html#gab42305b3a908062ad67fde4ee42e9947" title="This API is used to send 32 bit value to remote core and interrupt remote processor. ">IpcLib_interruptSendEvent()</a> - with valid payload and event id</li>
</ol>
<p>Essentially IpcLib allows receivers to register multiple callback functions. Number of callbacks is capped by IPCLIB_MAX_EVENTS. The module maintains this callback table and delivers message to right callback upon receiving interrupt. It multiplexes over single interrupt line from sender M to receiver N. This gives applications more flexibilty with minimal system resource suage.</p>
<p>Message delivery from sender to receiver</p>
<p>IpcLib allows 32 bit value to be sent across. Depending upon value of message it uses one or two mailbox entries. It uses last 5 bits of first message as eventId, if payload value fits into rest 27 bits it sends the single message or else it utilizes another message. ISR in the ipclib ensures messages are delivered correctly. These are implementation details and application writer need not worry about this.</p>
<p>IMPORTANT NOTE - IpcLib does not take care of synchronization between sender and receiver application. </p>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2019, Texas Instruments Incorporated</small>
</body>
</html>
