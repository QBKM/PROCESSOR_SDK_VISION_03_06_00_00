<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SBL TDA3xx Lib</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SBL TDA3xx Lib</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:sbl__lib__tda3xx_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbl__lib__tda3xx_8h.html">sbl_lib_tda3xx.h</a></td></tr>
<tr class="memdesc:sbl__lib__tda3xx_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains the interfaces present in the Secondary Bootloader(SBL) Library valid only for TDA3xx platform. This also contains some related macros, structures and enums. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga44e80a8a04889cce2f18bba9f7ad95a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga44e80a8a04889cce2f18bba9f7ad95a1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga44e80a8a04889cce2f18bba9f7ad95a1">SBLLIB_MAX_MPU_CORES</a>&#160;&#160;&#160;((uint32_t) 0U)</td></tr>
<tr class="memdesc:ga44e80a8a04889cce2f18bba9f7ad95a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro contains the maximum number of MPU cores where each dual core MPU subsystem is counted as two cores. <br /></td></tr>
<tr class="separator:ga44e80a8a04889cce2f18bba9f7ad95a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94fc75645f7d111040637ecbe1e8e2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf94fc75645f7d111040637ecbe1e8e2c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gaf94fc75645f7d111040637ecbe1e8e2c">SBLLIB_MAX_IPU_CORES</a>&#160;&#160;&#160;((uint32_t) 2U)</td></tr>
<tr class="memdesc:gaf94fc75645f7d111040637ecbe1e8e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro contains the maximum number of M4 cores in the system. <br /></td></tr>
<tr class="separator:gaf94fc75645f7d111040637ecbe1e8e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d837dde670627680aa35afd25a0c49e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6d837dde670627680aa35afd25a0c49e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga6d837dde670627680aa35afd25a0c49e">SBLLIB_MAX_DSP_CORES</a>&#160;&#160;&#160;((uint32_t) 2U)</td></tr>
<tr class="memdesc:ga6d837dde670627680aa35afd25a0c49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro contains the maximum number of DSP cores. <br /></td></tr>
<tr class="separator:ga6d837dde670627680aa35afd25a0c49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f51e53a900faa38e4ec8a46c66dd5eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0f51e53a900faa38e4ec8a46c66dd5eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga0f51e53a900faa38e4ec8a46c66dd5eb">SBLLIB_MAX_EVE_CORES</a>&#160;&#160;&#160;((uint32_t) 1U)</td></tr>
<tr class="memdesc:ga0f51e53a900faa38e4ec8a46c66dd5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro contains the maximum number of EVE cores. <br /></td></tr>
<tr class="separator:ga0f51e53a900faa38e4ec8a46c66dd5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff087f81b1b5d0e9d27bde6ee9cd22c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaff087f81b1b5d0e9d27bde6ee9cd22c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gaff087f81b1b5d0e9d27bde6ee9cd22c1">SBLLIB_IPU1_CORE1_BOOT_ADDRESS_NO_IMAGE</a>&#160;&#160;&#160;((uint32_t) 0x80000201U)</td></tr>
<tr class="memdesc:gaff087f81b1b5d0e9d27bde6ee9cd22c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro contains the IPU1 Core1's boot address when there is no App Image for IPU1 Core1. <br /></td></tr>
<tr class="separator:gaff087f81b1b5d0e9d27bde6ee9cd22c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8365da1a9b4b74232777b8bc7a746eb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8365da1a9b4b74232777b8bc7a746eb4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga8365da1a9b4b74232777b8bc7a746eb4">SBLLIB_IPU1_CORE_1_ENTRY_POINT_ADDRESS</a>&#160;&#160;&#160;((uint32_t) 0x00300180U)</td></tr>
<tr class="memdesc:ga8365da1a9b4b74232777b8bc7a746eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro contains the Address where IPU1 Core1 Entry Point is written and read. <br /></td></tr>
<tr class="separator:ga8365da1a9b4b74232777b8bc7a746eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762c653488197b74f040a337cdef63a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga762c653488197b74f040a337cdef63a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga762c653488197b74f040a337cdef63a6">SBLLIB_SOC_IPU_RAM_BASE</a>&#160;&#160;&#160;((uint32_t) 0x00000000U)</td></tr>
<tr class="memdesc:ga762c653488197b74f040a337cdef63a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro contains the IPU1's internal RAM base address as accessed from IPU. <br /></td></tr>
<tr class="separator:ga762c653488197b74f040a337cdef63a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1c8b209524c48ed68c7a7f99dada6301"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga1c8b209524c48ed68c7a7f99dada6301">SBLLibCalculateCRCFxn</a>) (const void *srcAddr, uint32_t crcDataSize, crcSignature_t *crcSignVal)</td></tr>
<tr class="memdesc:ga1c8b209524c48ed68c7a7f99dada6301"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains the prototype of SBL function used for calculating CRC.  <a href="#ga1c8b209524c48ed68c7a7f99dada6301">More...</a><br /></td></tr>
<tr class="separator:ga1c8b209524c48ed68c7a7f99dada6301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6daed6e4a5d88c9d535aa52b892ad6c"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gad6daed6e4a5d88c9d535aa52b892ad6c">SBLLibAuthenticateRPRCFxn</a>) (uint32_t rprcAddr, uint32_t rprcDataSize)</td></tr>
<tr class="memdesc:gad6daed6e4a5d88c9d535aa52b892ad6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains the prototype of SBL function used for authenticating RPRC images.  <a href="#gad6daed6e4a5d88c9d535aa52b892ad6c">More...</a><br /></td></tr>
<tr class="separator:gad6daed6e4a5d88c9d535aa52b892ad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace738a51a19470bd0ffd95efe6cca105"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace738a51a19470bd0ffd95efe6cca105"></a>
typedef enum <a class="el" href="group___s_b_l___t_d_a2_x_x___l_i_b.html#ga001b3c3e8bb2af2ed211102a9cc7db2b">sbllibCoreId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gace738a51a19470bd0ffd95efe6cca105">sbllibCoreId_t</a></td></tr>
<tr class="memdesc:gace738a51a19470bd0ffd95efe6cca105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to select the Core Id. Each dual core CPU is considered as two separate cores to get number of individual cores. Dual core CPU is added as one core in the end. <br /></td></tr>
<tr class="separator:gace738a51a19470bd0ffd95efe6cca105"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga001b3c3e8bb2af2ed211102a9cc7db2b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga001b3c3e8bb2af2ed211102a9cc7db2b">sbllibCoreId</a> { <br />
&#160;&#160;<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bad6804b24838b61cf538de36653389d51">SBLLIB_CORE_ID_MPU_CPU0</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2ba09facaa35beae921ae4664a09f240be7">SBLLIB_CORE_ID_MPU_CPU1</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2baeda7623ede57f80b4fc9a5f1fd74c443">SBLLIB_CORE_ID_IPU1_CPU0</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bacb20c258f0a78d567d2554e02258f57d">SBLLIB_CORE_ID_IPU1_CPU1</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bab21c70d7414975286c2f5876616b25bc">SBLLIB_CORE_ID_IPU1</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bac01b8b58e09db6c7958f74a1e4137d39">SBLLIB_CORE_ID_IPU2_CPU0</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bacd90871da89dd162257006a59a1325c3">SBLLIB_CORE_ID_IPU2_CPU1</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2ba02a24a049f05481b57a3f9c95a6d839a">SBLLIB_CORE_ID_IPU2</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2ba7a4a89cc50151f607a0b824630f89eab">SBLLIB_CORE_ID_DSP1</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2babee3bc2f3018cf660dc54a802b6bddf0">SBLLIB_CORE_ID_DSP2</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bae68720108f5c58d23cc50f36d0d288f9">SBLLIB_CORE_ID_EVE1</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bae933fb9af89b860c4c1f4492a47711dc">SBLLIB_CORE_ID_EVE2</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2ba7a226967c71d5edc1f020fd4abd5f508">SBLLIB_CORE_ID_EVE3</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bacdb6a30c2c0c0353616f6eddbf3c1d57">SBLLIB_CORE_ID_EVE4</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bab7b1299002144d945b626d65bab2c144">SBLLIB_CORE_ID_MPU</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2ba491b06ecabafe63de61fac59d492b24f">SBLLIB_CORE_MAX</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bad6804b24838b61cf538de36653389d51">SBLLIB_CORE_ID_MPU_CPU0</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2ba09facaa35beae921ae4664a09f240be7">SBLLIB_CORE_ID_MPU_CPU1</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2baeda7623ede57f80b4fc9a5f1fd74c443">SBLLIB_CORE_ID_IPU1_CPU0</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bacb20c258f0a78d567d2554e02258f57d">SBLLIB_CORE_ID_IPU1_CPU1</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bac01b8b58e09db6c7958f74a1e4137d39">SBLLIB_CORE_ID_IPU2_CPU0</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bacd90871da89dd162257006a59a1325c3">SBLLIB_CORE_ID_IPU2_CPU1</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2ba7a4a89cc50151f607a0b824630f89eab">SBLLIB_CORE_ID_DSP1</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2babee3bc2f3018cf660dc54a802b6bddf0">SBLLIB_CORE_ID_DSP2</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bae68720108f5c58d23cc50f36d0d288f9">SBLLIB_CORE_ID_EVE1</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bae933fb9af89b860c4c1f4492a47711dc">SBLLIB_CORE_ID_EVE2</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2ba7a226967c71d5edc1f020fd4abd5f508">SBLLIB_CORE_ID_EVE3</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bacdb6a30c2c0c0353616f6eddbf3c1d57">SBLLIB_CORE_ID_EVE4</a>, 
<br />
&#160;&#160;<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2ba9b95798d7594d2c380ef0e7fad841476">SBLLIB_CORE_INDIVIDUAL_MAX</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bab7b1299002144d945b626d65bab2c144">SBLLIB_CORE_ID_MPU</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2bab21c70d7414975286c2f5876616b25bc">SBLLIB_CORE_ID_IPU1</a>, 
<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gga001b3c3e8bb2af2ed211102a9cc7db2ba02a24a049f05481b57a3f9c95a6d839a">SBLLIB_CORE_ID_IPU2</a>
<br />
 }</td></tr>
<tr class="memdesc:ga001b3c3e8bb2af2ed211102a9cc7db2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to select the Core Id. Each dual core CPU is considered as two separate cores to get number of individual cores. Dual core CPU is added as one core in the end.  <a href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga001b3c3e8bb2af2ed211102a9cc7db2b">More...</a><br /></td></tr>
<tr class="separator:ga001b3c3e8bb2af2ed211102a9cc7db2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0efe42e06e30992c526e810a32967254"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga0efe42e06e30992c526e810a32967254">SBLLibRunTesocTest</a> (uint32_t testId, const tesocTestCfg_t *tesocTestConfig)</td></tr>
<tr class="memdesc:ga0efe42e06e30992c526e810a32967254"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function runs the TESOC test for the selected test ID. It powers down the test module's clock domain and starts the TESOC test.  <a href="#ga0efe42e06e30992c526e810a32967254">More...</a><br /></td></tr>
<tr class="separator:ga0efe42e06e30992c526e810a32967254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4670457a9a0a904a84aa168b3662d2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga6b4670457a9a0a904a84aa168b3662d2">SBLLibCheckTesocTestResult</a> (const tesocTestCfg_t *tesocTestConfig)</td></tr>
<tr class="memdesc:ga6b4670457a9a0a904a84aa168b3662d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API checks the result of last run TESOC test. It reads TESOC registers to get the result value and there is only one set of registers in TESOC IP. Thus this API is dependent on last run TESOC test.  <a href="#ga6b4670457a9a0a904a84aa168b3662d2">More...</a><br /></td></tr>
<tr class="separator:ga6b4670457a9a0a904a84aa168b3662d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5afc73416c336538d915f1bc32247e60"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga5afc73416c336538d915f1bc32247e60">SBLLibRegisterCRCCallback</a> (<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga1c8b209524c48ed68c7a7f99dada6301">SBLLibCalculateCRCFxn</a> calculateCRCFxn)</td></tr>
<tr class="memdesc:ga5afc73416c336538d915f1bc32247e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers the CRC calculation callback function which is used for checking integrity of multi-core App image.  <a href="#ga5afc73416c336538d915f1bc32247e60">More...</a><br /></td></tr>
<tr class="separator:ga5afc73416c336538d915f1bc32247e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b99b21e7f0c8cf956fdd1f6b3668c3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gae5b99b21e7f0c8cf956fdd1f6b3668c3">SBLLibRegisterAuthenticateRPRCCallback</a> (<a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gad6daed6e4a5d88c9d535aa52b892ad6c">SBLLibAuthenticateRPRCFxn</a> authenticateRPRCFxn)</td></tr>
<tr class="memdesc:gae5b99b21e7f0c8cf956fdd1f6b3668c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers the RPRC authentication callback function which is used for checking integrity of multi-core App image.  <a href="#gae5b99b21e7f0c8cf956fdd1f6b3668c3">More...</a><br /></td></tr>
<tr class="separator:gae5b99b21e7f0c8cf956fdd1f6b3668c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gad6daed6e4a5d88c9d535aa52b892ad6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* SBLLibAuthenticateRPRCFxn) (uint32_t rprcAddr, uint32_t rprcDataSize)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This typedef contains the prototype of SBL function used for authenticating RPRC images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rprcAddr</td><td>Source address of data RPRC image </td></tr>
    <tr><td class="paramname">rprcDataSize</td><td>Size of the RPRC image</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether RPRC is authenticated STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c8b209524c48ed68c7a7f99dada6301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* SBLLibCalculateCRCFxn) (const void *srcAddr, uint32_t crcDataSize, crcSignature_t *crcSignVal)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This typedef contains the prototype of SBL function used for calculating CRC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcAddr</td><td>Source address of data for which CRC is calculated </td></tr>
    <tr><td class="paramname">crcDataSize</td><td>Size of the CRC Data </td></tr>
    <tr><td class="paramname">crcSignVal</td><td>Value of CRC Signature</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether CRC is calculated successfully STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga001b3c3e8bb2af2ed211102a9cc7db2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_b_l___t_d_a2_x_x___l_i_b.html#ga001b3c3e8bb2af2ed211102a9cc7db2b">sbllibCoreId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to select the Core Id. Each dual core CPU is considered as two separate cores to get number of individual cores. Dual core CPU is added as one core in the end. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bad6804b24838b61cf538de36653389d51"></a>SBLLIB_CORE_ID_MPU_CPU0&#160;</td><td class="fielddoc">
<p>Core: Cortex A15 CPU0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2ba09facaa35beae921ae4664a09f240be7"></a>SBLLIB_CORE_ID_MPU_CPU1&#160;</td><td class="fielddoc">
<p>Core: Cortex A15 CPU1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2baeda7623ede57f80b4fc9a5f1fd74c443"></a>SBLLIB_CORE_ID_IPU1_CPU0&#160;</td><td class="fielddoc">
<p>Core: Cortex M4 (IPU1) CPU0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bacb20c258f0a78d567d2554e02258f57d"></a>SBLLIB_CORE_ID_IPU1_CPU1&#160;</td><td class="fielddoc">
<p>Core: Cortex M4 (IPU1) CPU1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bab21c70d7414975286c2f5876616b25bc"></a>SBLLIB_CORE_ID_IPU1&#160;</td><td class="fielddoc">
<p>Core: Dual Cortex M4 (IPU1) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bac01b8b58e09db6c7958f74a1e4137d39"></a>SBLLIB_CORE_ID_IPU2_CPU0&#160;</td><td class="fielddoc">
<p>Core: Cortex M4 (IPU2) CPU0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bacd90871da89dd162257006a59a1325c3"></a>SBLLIB_CORE_ID_IPU2_CPU1&#160;</td><td class="fielddoc">
<p>Core: Cortex M4 (IPU2) CPU1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2ba02a24a049f05481b57a3f9c95a6d839a"></a>SBLLIB_CORE_ID_IPU2&#160;</td><td class="fielddoc">
<p>Core: Dual Cortex M4 (IPU2) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2ba7a4a89cc50151f607a0b824630f89eab"></a>SBLLIB_CORE_ID_DSP1&#160;</td><td class="fielddoc">
<p>Core: C66x DSP1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2babee3bc2f3018cf660dc54a802b6bddf0"></a>SBLLIB_CORE_ID_DSP2&#160;</td><td class="fielddoc">
<p>Core: C66x DSP2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bae68720108f5c58d23cc50f36d0d288f9"></a>SBLLIB_CORE_ID_EVE1&#160;</td><td class="fielddoc">
<p>Core: EVE1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bae933fb9af89b860c4c1f4492a47711dc"></a>SBLLIB_CORE_ID_EVE2&#160;</td><td class="fielddoc">
<p>Core: EVE2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2ba7a226967c71d5edc1f020fd4abd5f508"></a>SBLLIB_CORE_ID_EVE3&#160;</td><td class="fielddoc">
<p>Core: EVE3 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bacdb6a30c2c0c0353616f6eddbf3c1d57"></a>SBLLIB_CORE_ID_EVE4&#160;</td><td class="fielddoc">
<p>Core: EVE4 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bab7b1299002144d945b626d65bab2c144"></a>SBLLIB_CORE_ID_MPU&#160;</td><td class="fielddoc">
<p>Core: Dual Cortex A15 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2ba491b06ecabafe63de61fac59d492b24f"></a>SBLLIB_CORE_MAX&#160;</td><td class="fielddoc">
<p>Enum value for maximum number of cores </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bad6804b24838b61cf538de36653389d51"></a>SBLLIB_CORE_ID_MPU_CPU0&#160;</td><td class="fielddoc">
<p>Core: Cortex A15 CPU0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2ba09facaa35beae921ae4664a09f240be7"></a>SBLLIB_CORE_ID_MPU_CPU1&#160;</td><td class="fielddoc">
<p>Core: Cortex A15 CPU1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2baeda7623ede57f80b4fc9a5f1fd74c443"></a>SBLLIB_CORE_ID_IPU1_CPU0&#160;</td><td class="fielddoc">
<p>Core: Cortex M4 (IPU1) CPU0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bacb20c258f0a78d567d2554e02258f57d"></a>SBLLIB_CORE_ID_IPU1_CPU1&#160;</td><td class="fielddoc">
<p>Core: Cortex M4 (IPU1) CPU1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bac01b8b58e09db6c7958f74a1e4137d39"></a>SBLLIB_CORE_ID_IPU2_CPU0&#160;</td><td class="fielddoc">
<p>Core: Cortex M4 (IPU2) CPU0 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bacd90871da89dd162257006a59a1325c3"></a>SBLLIB_CORE_ID_IPU2_CPU1&#160;</td><td class="fielddoc">
<p>Core: Cortex M4 (IPU2) CPU1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2ba7a4a89cc50151f607a0b824630f89eab"></a>SBLLIB_CORE_ID_DSP1&#160;</td><td class="fielddoc">
<p>Core: C66x DSP1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2babee3bc2f3018cf660dc54a802b6bddf0"></a>SBLLIB_CORE_ID_DSP2&#160;</td><td class="fielddoc">
<p>Core: C66x DSP2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bae68720108f5c58d23cc50f36d0d288f9"></a>SBLLIB_CORE_ID_EVE1&#160;</td><td class="fielddoc">
<p>Core: EVE1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bae933fb9af89b860c4c1f4492a47711dc"></a>SBLLIB_CORE_ID_EVE2&#160;</td><td class="fielddoc">
<p>Core: EVE2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2ba7a226967c71d5edc1f020fd4abd5f508"></a>SBLLIB_CORE_ID_EVE3&#160;</td><td class="fielddoc">
<p>Core: EVE3 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bacdb6a30c2c0c0353616f6eddbf3c1d57"></a>SBLLIB_CORE_ID_EVE4&#160;</td><td class="fielddoc">
<p>Core: EVE4 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2ba9b95798d7594d2c380ef0e7fad841476"></a>SBLLIB_CORE_INDIVIDUAL_MAX&#160;</td><td class="fielddoc">
<p>Enum value for maximum number individual cores </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bab7b1299002144d945b626d65bab2c144"></a>SBLLIB_CORE_ID_MPU&#160;</td><td class="fielddoc">
<p>Core: Dual Cortex A15 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2bab21c70d7414975286c2f5876616b25bc"></a>SBLLIB_CORE_ID_IPU1&#160;</td><td class="fielddoc">
<p>Core: Dual Cortex M4 (IPU1) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga001b3c3e8bb2af2ed211102a9cc7db2ba02a24a049f05481b57a3f9c95a6d839a"></a>SBLLIB_CORE_ID_IPU2&#160;</td><td class="fielddoc">
<p>Core: Dual Cortex M4 (IPU2) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6b4670457a9a0a904a84aa168b3662d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLLibCheckTesocTestResult </td>
          <td>(</td>
          <td class="paramtype">const tesocTestCfg_t *&#160;</td>
          <td class="paramname"><em>tesocTestConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API checks the result of last run TESOC test. It reads TESOC registers to get the result value and there is only one set of registers in TESOC IP. Thus this API is dependent on last run TESOC test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tesocTestConfig</td><td>TESOC test configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result TESOC test result. STW_SOK : Test Passed. STW_EFAIL : Test Failed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The test configuration should be exactly same as the one used for running TESOC test. </dd></dl>

</div>
</div>
<a class="anchor" id="gae5b99b21e7f0c8cf956fdd1f6b3668c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLLibRegisterAuthenticateRPRCCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#gad6daed6e4a5d88c9d535aa52b892ad6c">SBLLibAuthenticateRPRCFxn</a>&#160;</td>
          <td class="paramname"><em>authenticateRPRCFxn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function registers the RPRC authentication callback function which is used for checking integrity of multi-core App image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">authenticateRPRCFxn</td><td>Function for authenticating(/decrypting) RPRC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether call back function is assigned correctly STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga5afc73416c336538d915f1bc32247e60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLLibRegisterCRCCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_b_l___t_d_a3_x_x___l_i_b.html#ga1c8b209524c48ed68c7a7f99dada6301">SBLLibCalculateCRCFxn</a>&#160;</td>
          <td class="paramname"><em>calculateCRCFxn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function registers the CRC calculation callback function which is used for checking integrity of multi-core App image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">calculateCRCFxn</td><td>Function for calculating CRC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether call back function is assigned correctly STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga0efe42e06e30992c526e810a32967254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLLibRunTesocTest </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>testId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tesocTestCfg_t *&#160;</td>
          <td class="paramname"><em>tesocTestConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function runs the TESOC test for the selected test ID. It powers down the test module's clock domain and starts the TESOC test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">testId</td><td>Test ID for which TESOC test should be run. Refer enum tesocTestId_t for values. </td></tr>
    <tr><td class="paramname">tesocTestConfig</td><td>TESOC test configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether TESOC test is configured and started correctly. STW_SOK : Success STW_EFAIL : Failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The application should configure TESOC's clock, dividers, etc. appropriately so that TESOC test runs correctly. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2019, Texas Instruments Incorporated</small>
</body>
</html>
