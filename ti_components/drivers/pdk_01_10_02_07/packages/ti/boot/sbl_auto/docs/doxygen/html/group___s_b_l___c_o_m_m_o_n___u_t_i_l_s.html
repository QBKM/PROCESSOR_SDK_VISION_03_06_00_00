<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SBL Common Utilities</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SBL Common Utilities</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:sbl__utils__common_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sbl__utils__common_8h.html">sbl_utils_common.h</a></td></tr>
<tr class="memdesc:sbl__utils__common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file contains the SBL Utility layer common for all platforms. This also contains some related macros, structures and enums. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsblutils_power_domain_state_config.html">sblutilsPowerDomainStateConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines the Power Domain's configuration for configuring state of Power domain.  <a href="structsblutils_power_domain_state_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsblutils_clock_domain_state_config.html">sblutilsClockDomainStateConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines the Clock Domain's configuration for configuring state of clock domain.  <a href="structsblutils_clock_domain_state_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsblutils_module_enable_config.html">sblutilsModuleEnableConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines the Module's configuration for enabling Module mode.  <a href="structsblutils_module_enable_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga193fa204391a42d16609cdd1f9947218"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga193fa204391a42d16609cdd1f9947218"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga193fa204391a42d16609cdd1f9947218">SBL_UTILS_NOR_BASE</a>&#160;&#160;&#160;((uint32_t) 0x08000000U)</td></tr>
<tr class="memdesc:ga193fa204391a42d16609cdd1f9947218"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro contains the base address of NOR memory. <br /></td></tr>
<tr class="separator:ga193fa204391a42d16609cdd1f9947218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2692276e17fa73999d1be663557062e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2692276e17fa73999d1be663557062e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga2692276e17fa73999d1be663557062e6">SBL_UTILS_APP_IMAGE_OFFSET_NOR</a>&#160;&#160;&#160;((uint32_t) 0x00080000U)</td></tr>
<tr class="memdesc:ga2692276e17fa73999d1be663557062e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro contains the offset at which App Image is present in NOR memory. <br /></td></tr>
<tr class="separator:ga2692276e17fa73999d1be663557062e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ca667b50572998d0f33350a738cc21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92ca667b50572998d0f33350a738cc21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga92ca667b50572998d0f33350a738cc21">SBL_UTILS_APP_IMAGE_OFFSET_QSPI</a>&#160;&#160;&#160;((uint32_t) 0x00080000U)</td></tr>
<tr class="memdesc:ga92ca667b50572998d0f33350a738cc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro contains the offset at which App Image is present in QSPI flash. <br /></td></tr>
<tr class="separator:ga92ca667b50572998d0f33350a738cc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1200357af12f65d02b6ce71a71c7a5cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga1200357af12f65d02b6ce71a71c7a5cc">SBL_UTILS_I2C_SYSTEM_CLOCK</a>&#160;&#160;&#160;((uint32_t) 96000000U)</td></tr>
<tr class="separator:ga1200357af12f65d02b6ce71a71c7a5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387d352716d81ec1f56a4d293f88acb4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga387d352716d81ec1f56a4d293f88acb4">SBL_UTILS_I2C_INTERNAL_CLOCK</a>&#160;&#160;&#160;((uint32_t) 9600000U)</td></tr>
<tr class="separator:ga387d352716d81ec1f56a4d293f88acb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ee4d726fa6e31ce4806633063f4f4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gae3ee4d726fa6e31ce4806633063f4f4f">SBL_UTILS_I2C_OUTPUT_CLOCK</a>&#160;&#160;&#160;((uint32_t) 400000U)</td></tr>
<tr class="separator:gae3ee4d726fa6e31ce4806633063f4f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5335caff3f0e0defbb92f6a34e873380"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga5335caff3f0e0defbb92f6a34e873380">SBL_UTILS_I2C_TIMEOUT_COUNT</a>&#160;&#160;&#160;((uint32_t) 4000U)</td></tr>
<tr class="separator:ga5335caff3f0e0defbb92f6a34e873380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga016935b9609535ff172322c147ff5693"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga016935b9609535ff172322c147ff5693">SBL_UTILS_I2C_WRITE</a>&#160;&#160;&#160;((uint32_t) 1U)</td></tr>
<tr class="separator:ga016935b9609535ff172322c147ff5693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99bda844aed47fdedfe922bbb86c0ac2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga99bda844aed47fdedfe922bbb86c0ac2">SBL_UTILS_I2C_READ</a>&#160;&#160;&#160;((uint32_t) 2U)</td></tr>
<tr class="separator:ga99bda844aed47fdedfe922bbb86c0ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga16987b1df45faec7b19938ed610bf03f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga16987b1df45faec7b19938ed610bf03f"></a>
typedef struct <a class="el" href="structsblutils_power_domain_state_config.html">sblutilsPowerDomainStateConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga16987b1df45faec7b19938ed610bf03f">sblutilsPowerDomainStateConfig_t</a></td></tr>
<tr class="memdesc:ga16987b1df45faec7b19938ed610bf03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines the Power Domain's configuration for configuring state of Power domain. <br /></td></tr>
<tr class="separator:ga16987b1df45faec7b19938ed610bf03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae1660b3967769039bfeac8c0db77a7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaae1660b3967769039bfeac8c0db77a7a"></a>
typedef struct <a class="el" href="structsblutils_clock_domain_state_config.html">sblutilsClockDomainStateConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gaae1660b3967769039bfeac8c0db77a7a">sblutilsClockDomainStateConfig_t</a></td></tr>
<tr class="memdesc:gaae1660b3967769039bfeac8c0db77a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines the Clock Domain's configuration for configuring state of clock domain. <br /></td></tr>
<tr class="separator:gaae1660b3967769039bfeac8c0db77a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaf2c6ccf06a8cf24778527863a363ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeaf2c6ccf06a8cf24778527863a363ba"></a>
typedef struct <a class="el" href="structsblutils_module_enable_config.html">sblutilsModuleEnableConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gaeaf2c6ccf06a8cf24778527863a363ba">sblutilsModuleEnableConfig_t</a></td></tr>
<tr class="memdesc:gaeaf2c6ccf06a8cf24778527863a363ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure defines the Module's configuration for enabling Module mode. <br /></td></tr>
<tr class="separator:gaeaf2c6ccf06a8cf24778527863a363ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga262a0393482c16ae042c44cf0d0002d5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga262a0393482c16ae042c44cf0d0002d5">SBLUtilsQspiBootRprc</a> (<a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a">sbllibAppImageParseParams_t</a> *imageParams)</td></tr>
<tr class="memdesc:ga262a0393482c16ae042c44cf0d0002d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses and copies the App Image from QSPI flash in QSPI boot mode.  <a href="#ga262a0393482c16ae042c44cf0d0002d5">More...</a><br /></td></tr>
<tr class="separator:ga262a0393482c16ae042c44cf0d0002d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6d3d488184ee15abb3cea9774cbd969"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gaf6d3d488184ee15abb3cea9774cbd969">SBLUtilsQspiReadSectors</a> (void *dstAddr, uint32_t srcOffsetAddr, uint32_t length)</td></tr>
<tr class="memdesc:gaf6d3d488184ee15abb3cea9774cbd969"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies data from QSPI flash. It uses EDMA for complete transfer.  <a href="#gaf6d3d488184ee15abb3cea9774cbd969">More...</a><br /></td></tr>
<tr class="separator:gaf6d3d488184ee15abb3cea9774cbd969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab202a8edc3a79dc0822138d012be768b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gab202a8edc3a79dc0822138d012be768b">SBLUtilsQspiSDBootRprc</a> (<a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a">sbllibAppImageParseParams_t</a> *imageParams)</td></tr>
<tr class="memdesc:gab202a8edc3a79dc0822138d012be768b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses and copies the App Image from MMCSD card in QSPI_SD boot mode.  <a href="#gab202a8edc3a79dc0822138d012be768b">More...</a><br /></td></tr>
<tr class="separator:gab202a8edc3a79dc0822138d012be768b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67b677aaeba2f11a36b77855b33e24fc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga67b677aaeba2f11a36b77855b33e24fc">SBLUtilsSDBootRprc</a> (<a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a">sbllibAppImageParseParams_t</a> *imageParams)</td></tr>
<tr class="memdesc:ga67b677aaeba2f11a36b77855b33e24fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses and copies the App Image from MMCSD card in SD boot mode.  <a href="#ga67b677aaeba2f11a36b77855b33e24fc">More...</a><br /></td></tr>
<tr class="separator:ga67b677aaeba2f11a36b77855b33e24fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f5570967c3a4f98b21c3b2c7c06409a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga3f5570967c3a4f98b21c3b2c7c06409a">SBLUtilsSDFileRead</a> (void *dstbuff, uint32_t srcFileAddr, uint32_t numBytes)</td></tr>
<tr class="memdesc:ga3f5570967c3a4f98b21c3b2c7c06409a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies data from MMCSD card. It uses EDMA when data to be read is more than 512 bytes.  <a href="#ga3f5570967c3a4f98b21c3b2c7c06409a">More...</a><br /></td></tr>
<tr class="separator:ga3f5570967c3a4f98b21c3b2c7c06409a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb7e6864f87502eea3be7d84fa6434e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gafb7e6864f87502eea3be7d84fa6434e6">SBLUtilsSDFileSeek</a> (uint32_t *filePtr, uint32_t numBytes)</td></tr>
<tr class="memdesc:gafb7e6864f87502eea3be7d84fa6434e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function moves the file read head by n bytes.  <a href="#gafb7e6864f87502eea3be7d84fa6434e6">More...</a><br /></td></tr>
<tr class="separator:gafb7e6864f87502eea3be7d84fa6434e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa3f95e9e2b5448661ca06d465d6b76"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gabaa3f95e9e2b5448661ca06d465d6b76">SBLUtilsNorBootRprc</a> (<a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a">sbllibAppImageParseParams_t</a> *imageParams)</td></tr>
<tr class="memdesc:gabaa3f95e9e2b5448661ca06d465d6b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses and copies the App Image from NOR memory in NOR boot mode.  <a href="#gabaa3f95e9e2b5448661ca06d465d6b76">More...</a><br /></td></tr>
<tr class="separator:gabaa3f95e9e2b5448661ca06d465d6b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4fd7902ded9984eb7e8a31f2a0e81cd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gac4fd7902ded9984eb7e8a31f2a0e81cd">SBLUtilsNorRead</a> (void *dstAddr, uint32_t srcOffsetAddr, uint32_t length)</td></tr>
<tr class="memdesc:gac4fd7902ded9984eb7e8a31f2a0e81cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies data from NOR memory. It uses EDMA for complete transfer.  <a href="#gac4fd7902ded9984eb7e8a31f2a0e81cd">More...</a><br /></td></tr>
<tr class="separator:gac4fd7902ded9984eb7e8a31f2a0e81cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cd75f3e711e80864b693f2eb4bee60f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga1cd75f3e711e80864b693f2eb4bee60f">SBLUtilsNorFileSeek</a> (uint32_t *srcAddr, uint32_t numBytes)</td></tr>
<tr class="memdesc:ga1cd75f3e711e80864b693f2eb4bee60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function moves the read head by n bytes.  <a href="#ga1cd75f3e711e80864b693f2eb4bee60f">More...</a><br /></td></tr>
<tr class="separator:ga1cd75f3e711e80864b693f2eb4bee60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5321d2fe0a6630cc860ecc97a1c72b87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga5321d2fe0a6630cc860ecc97a1c72b87">SBLUtilsTriggerEDMAPolledMode</a> (uint32_t srcAddr, uint32_t destAddr, uint32_t dataSize, uint32_t edmaChannelNum, uint32_t edmaTccNum, uint32_t edmaEvtqNum, uint32_t paramSetNum)</td></tr>
<tr class="memdesc:ga5321d2fe0a6630cc860ecc97a1c72b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API triggers an EDMA transfer from source address to destination address.  <a href="#ga5321d2fe0a6630cc860ecc97a1c72b87">More...</a><br /></td></tr>
<tr class="separator:ga5321d2fe0a6630cc860ecc97a1c72b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66a4d73a4c27621276fd64fac6b929c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gaf66a4d73a4c27621276fd64fac6b929c">SBLUtilsConfigPowerDomains</a> (void)</td></tr>
<tr class="memdesc:gaf66a4d73a4c27621276fd64fac6b929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the wrapper function for configuring Power domains.  <a href="#gaf66a4d73a4c27621276fd64fac6b929c">More...</a><br /></td></tr>
<tr class="separator:gaf66a4d73a4c27621276fd64fac6b929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23e61fbe3a6b416be613f62ba4762e5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga23e61fbe3a6b416be613f62ba4762e5e">SBLUtilsConfigMultiOppDpll</a> (uint32_t oppId)</td></tr>
<tr class="memdesc:ga23e61fbe3a6b416be613f62ba4762e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the wrapper function for configuring DPLL. This function is implemented such that the error messages are printed on UART Console in case DPLL is not configured correctly.  <a href="#ga23e61fbe3a6b416be613f62ba4762e5e">More...</a><br /></td></tr>
<tr class="separator:ga23e61fbe3a6b416be613f62ba4762e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5416a7fe4be3d6614109b136e4c7c7a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga5416a7fe4be3d6614109b136e4c7c7a7">SBLUtilsConfigSingleOppDpll</a> (void)</td></tr>
<tr class="memdesc:ga5416a7fe4be3d6614109b136e4c7c7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the wrapper function for configuring DPLL. This function configures the DPLLs which usually donot support multiple OPPs. This function is implemented such that the error messages are printed on UART Console in case DPLL is not configured correctly.  <a href="#ga5416a7fe4be3d6614109b136e4c7c7a7">More...</a><br /></td></tr>
<tr class="separator:ga5416a7fe4be3d6614109b136e4c7c7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a2b9a6c1c2ea2a2f6667b1ccc1bd63d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga3a2b9a6c1c2ea2a2f6667b1ccc1bd63d">SBLUtilsConfigClockDomains</a> (void)</td></tr>
<tr class="memdesc:ga3a2b9a6c1c2ea2a2f6667b1ccc1bd63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the wrapper function for configuring clock domains. This function is implemented such that the error messages are printed on UART Console in case Clock Domain is not configured correctly.  <a href="#ga3a2b9a6c1c2ea2a2f6667b1ccc1bd63d">More...</a><br /></td></tr>
<tr class="separator:ga3a2b9a6c1c2ea2a2f6667b1ccc1bd63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24f298aaf073f83f9197b6ca7f8ab5da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga24f298aaf073f83f9197b6ca7f8ab5da">SBLUtilsConfigModules</a> (void)</td></tr>
<tr class="memdesc:ga24f298aaf073f83f9197b6ca7f8ab5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the wrapper function for enabling modules. This function is implemented such that the error messages are printed on UART Console in case modules are not enabled correctly.  <a href="#ga24f298aaf073f83f9197b6ca7f8ab5da">More...</a><br /></td></tr>
<tr class="separator:ga24f298aaf073f83f9197b6ca7f8ab5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e5f2ebfeb18dbadacc54ca0a6205696"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga7e5f2ebfeb18dbadacc54ca0a6205696">SBLUtilsConfigAllVoltageRails</a> (uint32_t oppId)</td></tr>
<tr class="memdesc:ga7e5f2ebfeb18dbadacc54ca0a6205696"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a wrapper function for configuring the AVS of Voltage rails of the device. This function returns the error status based on whether the voltage rails are configured correctly.  <a href="#ga7e5f2ebfeb18dbadacc54ca0a6205696">More...</a><br /></td></tr>
<tr class="separator:ga7e5f2ebfeb18dbadacc54ca0a6205696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d50173bf5ce18cc186faaacd75baca"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga40d50173bf5ce18cc186faaacd75baca">SBLUtilsRead32KTimer</a> (void)</td></tr>
<tr class="memdesc:ga40d50173bf5ce18cc186faaacd75baca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the 32K Timer value. This API is used to measure SBL boot time.  <a href="#ga40d50173bf5ce18cc186faaacd75baca">More...</a><br /></td></tr>
<tr class="separator:ga40d50173bf5ce18cc186faaacd75baca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f1375fcf385ceb0b8343327fc6867c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gaf4f1375fcf385ceb0b8343327fc6867c">SBLUtilsPrintfInit</a> (UART_INST_t uartInstance)</td></tr>
<tr class="memdesc:gaf4f1375fcf385ceb0b8343327fc6867c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the UART terminal for the given instance.  <a href="#gaf4f1375fcf385ceb0b8343327fc6867c">More...</a><br /></td></tr>
<tr class="separator:gaf4f1375fcf385ceb0b8343327fc6867c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae325adb38585c5e4b2ff4f6dada80e98"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gae325adb38585c5e4b2ff4f6dada80e98">SBLUtilsUartPrcm</a> (UART_INST_t uartInstance)</td></tr>
<tr class="memdesc:gae325adb38585c5e4b2ff4f6dada80e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does the PRCM configuration for given UART instance.  <a href="#gae325adb38585c5e4b2ff4f6dada80e98">More...</a><br /></td></tr>
<tr class="separator:gae325adb38585c5e4b2ff4f6dada80e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8836a1835b639192f026f9685ecfae50"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga8836a1835b639192f026f9685ecfae50">SBLUtilsDDRReadEdma</a> (void *dstAddr, uint32_t srcAddr, uint32_t length)</td></tr>
<tr class="memdesc:ga8836a1835b639192f026f9685ecfae50"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies data from DDR memory using EDMA.  <a href="#ga8836a1835b639192f026f9685ecfae50">More...</a><br /></td></tr>
<tr class="separator:ga8836a1835b639192f026f9685ecfae50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff080394fc4df8606a8a6f154a4834c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gafff080394fc4df8606a8a6f154a4834c">SBLUtilsGetDDRAppCopyAddress</a> (void)</td></tr>
<tr class="memdesc:gafff080394fc4df8606a8a6f154a4834c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the DDR address where App Image is copied before parsing. This might differ depending on the silicon package type.  <a href="#gafff080394fc4df8606a8a6f154a4834c">More...</a><br /></td></tr>
<tr class="separator:gafff080394fc4df8606a8a6f154a4834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f04a39d2c6d6df425b86e7d6edf83b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga58f04a39d2c6d6df425b86e7d6edf83b">SBLUtilsEmifECCConfigure</a> (void)</td></tr>
<tr class="memdesc:ga58f04a39d2c6d6df425b86e7d6edf83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures and enables the EMIF ECC using parameters from SBL config file.  <a href="#ga58f04a39d2c6d6df425b86e7d6edf83b">More...</a><br /></td></tr>
<tr class="separator:ga58f04a39d2c6d6df425b86e7d6edf83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fc23a08e1edf20baf2e93c4a994d0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#ga54fc23a08e1edf20baf2e93c4a994d0e">SBLUtilsPreFillECCMemory</a> (const void *eccMemStartAddr, const void *srcBuffAddr, uint32_t memSize)</td></tr>
<tr class="memdesc:ga54fc23a08e1edf20baf2e93c4a994d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function pre-fills the ECC memory with the known pattern present at source address.  <a href="#ga54fc23a08e1edf20baf2e93c4a994d0e">More...</a><br /></td></tr>
<tr class="separator:ga54fc23a08e1edf20baf2e93c4a994d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeea2383e9453d14697531bc4925046d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_b_l___c_o_m_m_o_n___u_t_i_l_s.html#gaeea2383e9453d14697531bc4925046d4">SBLUtilsInitDspL2RAM</a> (uint32_t dspCoreId)</td></tr>
<tr class="memdesc:gaeea2383e9453d14697531bc4925046d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the DSP L2 RAM to zero.  <a href="#gaeea2383e9453d14697531bc4925046d4">More...</a><br /></td></tr>
<tr class="separator:gaeea2383e9453d14697531bc4925046d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga387d352716d81ec1f56a4d293f88acb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SBL_UTILS_I2C_INTERNAL_CLOCK&#160;&#160;&#160;((uint32_t) 9600000U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Internal Clock - 9.6 MHz , Fast Mode of Communication is is used here. A pre-scaler of 23 would be calculated here. Refer TRM for details on the different I2C modes. </p>

</div>
</div>
<a class="anchor" id="gae3ee4d726fa6e31ce4806633063f4f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SBL_UTILS_I2C_OUTPUT_CLOCK&#160;&#160;&#160;((uint32_t) 400000U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Output Clock - 400 KHz, This complies with the Fast Mode of the I2C operation of 100 Kbps. </p>

</div>
</div>
<a class="anchor" id="ga99bda844aed47fdedfe922bbb86c0ac2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SBL_UTILS_I2C_READ&#160;&#160;&#160;((uint32_t) 2U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read Flag used when checking for the transfer status. </p>

</div>
</div>
<a class="anchor" id="ga1200357af12f65d02b6ce71a71c7a5cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SBL_UTILS_I2C_SYSTEM_CLOCK&#160;&#160;&#160;((uint32_t) 96000000U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C System Clock - PER_96M_CLK: 96 MHz </p>

</div>
</div>
<a class="anchor" id="ga5335caff3f0e0defbb92f6a34e873380"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SBL_UTILS_I2C_TIMEOUT_COUNT&#160;&#160;&#160;((uint32_t) 4000U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When checking for I2C IRQSTATUS setting this count is used to repeatedly check the status. This number is empirically derived. </p>

</div>
</div>
<a class="anchor" id="ga016935b9609535ff172322c147ff5693"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SBL_UTILS_I2C_WRITE&#160;&#160;&#160;((uint32_t) 1U)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write Flag used when checking for the transfer status. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7e5f2ebfeb18dbadacc54ca0a6205696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsConfigAllVoltageRails </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>oppId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a wrapper function for configuring the AVS of Voltage rails of the device. This function returns the error status based on whether the voltage rails are configured correctly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oppId</td><td>The OPP for which the voltage should be set for the voltage rails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PM_SUCCESS if opp is proper and voltage can be configured PM_FAIL/PM_TIMEOUT/PM_BADARGS otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a2b9a6c1c2ea2a2f6667b1ccc1bd63d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBLUtilsConfigClockDomains </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the wrapper function for configuring clock domains. This function is implemented such that the error messages are printed on UART Console in case Clock Domain is not configured correctly. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga24f298aaf073f83f9197b6ca7f8ab5da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBLUtilsConfigModules </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the wrapper function for enabling modules. This function is implemented such that the error messages are printed on UART Console in case modules are not enabled correctly. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga23e61fbe3a6b416be613f62ba4762e5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBLUtilsConfigMultiOppDpll </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>oppId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the wrapper function for configuring DPLL. This function is implemented such that the error messages are printed on UART Console in case DPLL is not configured correctly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oppId</td><td>The OPP for which the DPLLs should be configured.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaf66a4d73a4c27621276fd64fac6b929c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsConfigPowerDomains </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the wrapper function for configuring Power domains. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga5416a7fe4be3d6614109b136e4c7c7a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBLUtilsConfigSingleOppDpll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the wrapper function for configuring DPLL. This function configures the DPLLs which usually donot support multiple OPPs. This function is implemented such that the error messages are printed on UART Console in case DPLL is not configured correctly. </p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga8836a1835b639192f026f9685ecfae50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsDDRReadEdma </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies data from DDR memory using EDMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstAddr</td><td>Destination Address </td></tr>
    <tr><td class="paramname">srcAddr</td><td>DDR Source Address </td></tr>
    <tr><td class="paramname">length</td><td>The length of data block to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether data is copied correctly STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga58f04a39d2c6d6df425b86e7d6edf83b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsEmifECCConfigure </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures and enables the EMIF ECC using parameters from SBL config file. </p>
<dl class="section return"><dt>Returns</dt><dd>status ECC enable status. STW_SOK : ECC enabled successfully STW_EFAIL : Failed to enable ECC </dd></dl>

</div>
</div>
<a class="anchor" id="gafff080394fc4df8606a8a6f154a4834c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SBLUtilsGetDDRAppCopyAddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the DDR address where App Image is copied before parsing. This might differ depending on the silicon package type. </p>
<dl class="section return"><dt>Returns</dt><dd>ddrAddress Address where app image should be copied </dd></dl>

</div>
</div>
<a class="anchor" id="gaeea2383e9453d14697531bc4925046d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBLUtilsInitDspL2RAM </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dspCoreId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the DSP L2 RAM to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dspCoreId</td><td>DSP Core Id. SBLLIB_CORE_ID_DSP1: DSP1 SBLLIB_CORE_ID_DSP2: DSP2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gabaa3f95e9e2b5448661ca06d465d6b76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsNorBootRprc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a">sbllibAppImageParseParams_t</a> *&#160;</td>
          <td class="paramname"><em>imageParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses and copies the App Image from NOR memory in NOR boot mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageParams</td><td>Multi-core Application Image Parse Parameters. Refer struct <a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a" title="This structure defines the multi-core application image parse parameters. ">sbllibAppImageParseParams_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether image is parsed and copied correctly STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga1cd75f3e711e80864b693f2eb4bee60f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBLUtilsNorFileSeek </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>srcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function moves the read head by n bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcAddr</td><td>Read head pointer. </td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes of data by which read head is moved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gac4fd7902ded9984eb7e8a31f2a0e81cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsNorRead </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcOffsetAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies data from NOR memory. It uses EDMA for complete transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstAddr</td><td>Destination Address </td></tr>
    <tr><td class="paramname">srcOffsetAddr</td><td>NOR Source Offset Address </td></tr>
    <tr><td class="paramname">length</td><td>The length of data block to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether copy is done successfully. STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga54fc23a08e1edf20baf2e93c4a994d0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBLUtilsPreFillECCMemory </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>eccMemStartAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>srcBuffAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>memSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function pre-fills the ECC memory with the known pattern present at source address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eccMemStartAddr</td><td>Start address of memory for which ECC is enabled </td></tr>
    <tr><td class="paramname">srcBuffAddr</td><td>Address of the source buffer </td></tr>
    <tr><td class="paramname">memSize</td><td>Size of the memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API does not initialize and de-initialize the EDMA. This should be taken care by caller. Also the srcBuffer size should be equal to EDMA ACount value used in this API's implementation which is 128 bytes currently. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4f1375fcf385ceb0b8343327fc6867c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsPrintfInit </td>
          <td>(</td>
          <td class="paramtype">UART_INST_t&#160;</td>
          <td class="paramname"><em>uartInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the UART terminal for the given instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartInstance</td><td>Instance for which UART should be initialized. Refer enum UART_INST_t for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether UART is initialized correctly STW_SOK : Success STW_EFAIL : Failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API currently supports only UART3 instance. </dd></dl>

</div>
</div>
<a class="anchor" id="ga262a0393482c16ae042c44cf0d0002d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsQspiBootRprc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a">sbllibAppImageParseParams_t</a> *&#160;</td>
          <td class="paramname"><em>imageParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses and copies the App Image from QSPI flash in QSPI boot mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageParams</td><td>Multi-core Application Image Parse Parameters. Refer struct <a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a" title="This structure defines the multi-core application image parse parameters. ">sbllibAppImageParseParams_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether image is parsed and copied correctly STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6d3d488184ee15abb3cea9774cbd969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsQspiReadSectors </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcOffsetAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies data from QSPI flash. It uses EDMA for complete transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstAddr</td><td>Destination Address </td></tr>
    <tr><td class="paramname">srcOffsetAddr</td><td>QSPI Source Offset Address </td></tr>
    <tr><td class="paramname">length</td><td>The length of data block to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether copy is done successfully. STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="gab202a8edc3a79dc0822138d012be768b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsQspiSDBootRprc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a">sbllibAppImageParseParams_t</a> *&#160;</td>
          <td class="paramname"><em>imageParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses and copies the App Image from MMCSD card in QSPI_SD boot mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageParams</td><td>Multi-core Application Image Parse Parameters. Refer struct <a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a" title="This structure defines the multi-core application image parse parameters. ">sbllibAppImageParseParams_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether image is parsed and copied correctly STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga40d50173bf5ce18cc186faaacd75baca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SBLUtilsRead32KTimer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the 32K Timer value. This API is used to measure SBL boot time. </p>
<dl class="section return"><dt>Returns</dt><dd>timerVal Current Value of the 32K Counter </dd></dl>

</div>
</div>
<a class="anchor" id="ga67b677aaeba2f11a36b77855b33e24fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsSDBootRprc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a">sbllibAppImageParseParams_t</a> *&#160;</td>
          <td class="paramname"><em>imageParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses and copies the App Image from MMCSD card in SD boot mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageParams</td><td>Multi-core Application Image Parse Parameters. Refer struct <a class="el" href="group___s_b_l___l_i_b.html#ga283747412a7dbae15bdd59ffb2b3956a" title="This structure defines the multi-core application image parse parameters. ">sbllibAppImageParseParams_t</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether image is parsed and copied correctly STW_SOK : Success STW_EFAIL : Failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f5570967c3a4f98b21c3b2c7c06409a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsSDFileRead </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcFileAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function copies data from MMCSD card. It uses EDMA when data to be read is more than 512 bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstbuff</td><td>Destination Buffer Address </td></tr>
    <tr><td class="paramname">srcFileAddr</td><td>Source File Address </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes of data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether copy is done successfully. STW_SOK : Success STW_EFAIL : Failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API does not use the source file pointer parameter. It is a dummy added to maintain compatibility with Read Function prototype. </dd></dl>

</div>
</div>
<a class="anchor" id="gafb7e6864f87502eea3be7d84fa6434e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBLUtilsSDFileSeek </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>filePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function moves the file read head by n bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePtr</td><td>File read pointer </td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes of data by which read head is moved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API does not use the source file pointer parameter. It is a dummy added to maintain compatibility with Read Function prototype. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5321d2fe0a6630cc860ecc97a1c72b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SBLUtilsTriggerEDMAPolledMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>destAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>edmaChannelNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>edmaTccNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>edmaEvtqNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>paramSetNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API triggers an EDMA transfer from source address to destination address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcAddr</td><td>Source Address. </td></tr>
    <tr><td class="paramname">destAddr</td><td>Destination Address. </td></tr>
    <tr><td class="paramname">dataSize</td><td>Size of the data that needs to be copied. </td></tr>
    <tr><td class="paramname">edmaChannelNum</td><td>EDMA Channel Number. </td></tr>
    <tr><td class="paramname">edmaTccNum</td><td>EDMA TCC Number. </td></tr>
    <tr><td class="paramname">edmaEvtqNum</td><td>EDMA Event Queue Number. </td></tr>
    <tr><td class="paramname">paramSetNum</td><td>EDMA Param Set Number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gae325adb38585c5e4b2ff4f6dada80e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SBLUtilsUartPrcm </td>
          <td>(</td>
          <td class="paramtype">UART_INST_t&#160;</td>
          <td class="paramname"><em>uartInstance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function does the PRCM configuration for given UART instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartInstance</td><td>Instance for which PRCM should be configured. Refer enum UART_INST_t for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Whether UART PRCM is done correctly STW_SOK : Success STW_EFAIL : Failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API currently supports only UART3 instance. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2019, Texas Instruments Incorporated</small>
</body>
</html>
