<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>qspi_flash.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_149d487d07acd2e53f62a8902febc730.html">qspiflash</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">qspi_flash.h File Reference<div class="ingroups"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html">QSPI Flash Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This file contains the interfaces present in the QSPI Flash Library. This also contains some related macros, structures and enums.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;ti/csl/csl_edma.h&gt;</code><br />
<code>#include &lt;ti/csl/csl_qspi.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_s_p_i___config_desc__t.html">QSPI_ConfigDesc_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold configuration descriptor type.  <a href="struct_q_s_p_i___config_desc__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_s_p_i___flash_cmd__t.html">QSPI_FlashCmd_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold QSPI flash command parameters.  <a href="struct_q_s_p_i___flash_cmd__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_q_s_p_i___flash_dev_info__t.html">QSPI_FlashDevInfo_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold QSPI flash device info.  <a href="struct_q_s_p_i___flash_dev_info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga50ef2c8b4110fad5031aa27c41260b92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga50ef2c8b4110fad5031aa27c41260b92"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga50ef2c8b4110fad5031aa27c41260b92">QSPI_FLASH_SUCCESS</a>&#160;&#160;&#160;((uint32_t) 1U)</td></tr>
<tr class="memdesc:ga50ef2c8b4110fad5031aa27c41260b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro defines the Boolean that is used for True. <br /></td></tr>
<tr class="separator:ga50ef2c8b4110fad5031aa27c41260b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a3ef278d529ff0c830773dd8093271d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a3ef278d529ff0c830773dd8093271d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga1a3ef278d529ff0c830773dd8093271d">QSPI_FLASH_FAIL</a>&#160;&#160;&#160;((uint32_t) 0U)</td></tr>
<tr class="memdesc:ga1a3ef278d529ff0c830773dd8093271d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro defines the Boolean that is used for False. <br /></td></tr>
<tr class="separator:ga1a3ef278d529ff0c830773dd8093271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b9c397af312dde7cc774b4b0a3fcaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5b9c397af312dde7cc774b4b0a3fcaa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gad5b9c397af312dde7cc774b4b0a3fcaa">QSPI_FLASH_RESET_AT_INIT</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gad5b9c397af312dde7cc774b4b0a3fcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this macro to 1 to reset the flash at initialization Required only if QSPI boot mode is selected and connected using CCS/debugger. Production code need not do the reset, so default value set to 0. <br /></td></tr>
<tr class="separator:gad5b9c397af312dde7cc774b4b0a3fcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf124f13961b460ae96848f5e1919b23f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf124f13961b460ae96848f5e1919b23f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gaf124f13961b460ae96848f5e1919b23f">QSPIFLASH_BLOCKSIZE</a>&#160;&#160;&#160;(64U * 1024U)</td></tr>
<tr class="memdesc:gaf124f13961b460ae96848f5e1919b23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block size of QSPI flash. <br /></td></tr>
<tr class="separator:gaf124f13961b460ae96848f5e1919b23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade615a5f979da96796d0d505c47cee8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gade615a5f979da96796d0d505c47cee8e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gade615a5f979da96796d0d505c47cee8e">QSPIFLASH_SUBSECTORSIZE</a>&#160;&#160;&#160;(4U * 1024U)</td></tr>
<tr class="memdesc:gade615a5f979da96796d0d505c47cee8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sector size of QSPI flash. <br /></td></tr>
<tr class="separator:gade615a5f979da96796d0d505c47cee8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">QSPI Config ID's</div></td></tr>
<tr class="memitem:gaa1e2616d2422e7c6a2611aec95796a11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1e2616d2422e7c6a2611aec95796a11"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gaa1e2616d2422e7c6a2611aec95796a11">QSPI_CONFIGID_CLOCKSPEED</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:gaa1e2616d2422e7c6a2611aec95796a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock speed configuration id. <br /></td></tr>
<tr class="separator:gaa1e2616d2422e7c6a2611aec95796a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c3339276dbe02b37315282c040cb52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92c3339276dbe02b37315282c040cb52"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga92c3339276dbe02b37315282c040cb52">QSPI_CONFIGID_READCMD</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga92c3339276dbe02b37315282c040cb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read command configuration id. <br /></td></tr>
<tr class="separator:ga92c3339276dbe02b37315282c040cb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf9b127f32f9105c5f94873b5f44353af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf9b127f32f9105c5f94873b5f44353af"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gaf9b127f32f9105c5f94873b5f44353af">QSPI_flashInitFunPtr</a>) (qspi_DeviceType_e DeviceType)</td></tr>
<tr class="memdesc:gaf9b127f32f9105c5f94873b5f44353af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef contains the prototype of QSPI lib init function. <br /></td></tr>
<tr class="separator:gaf9b127f32f9105c5f94873b5f44353af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga6b1ca424645902d7bb1200c801bdf61c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga6b1ca424645902d7bb1200c801bdf61c">qspi_CR_WLEN_e</a> { <br />
&#160;&#160;<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gga6b1ca424645902d7bb1200c801bdf61ca4cd1c35112f030cd16f6d3ab5c42ca1f">QSPI_CR_WLEN_1_BIT</a> = 0x0, 
<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gga6b1ca424645902d7bb1200c801bdf61cae42d509ec3d18c6081d7b4493d7cfa9c">QSPI_CR_WLEN_8_BITS</a> = 0x7, 
<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gga6b1ca424645902d7bb1200c801bdf61ca6e11c6c211bbbc6dae9eb6472a543397">QSPI_CR_WLEN_16_BITS</a> = 0xF, 
<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gga6b1ca424645902d7bb1200c801bdf61cad081dd17122af408b115215fecfbb21e">QSPI_CR_WLEN_24_BITS</a> = 0x17, 
<br />
&#160;&#160;<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gga6b1ca424645902d7bb1200c801bdf61ca92e478adb87b3502e7af361e5e9d0fc7">QSPI_CR_WLEN_32_BITS</a> = 0x1F, 
<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gga6b1ca424645902d7bb1200c801bdf61ca16432ec1d3333206d40d3daa388775c4">QSPI_CR_WLEN_128_BITS</a> = 0x7F
<br />
 }</td></tr>
<tr class="memdesc:ga6b1ca424645902d7bb1200c801bdf61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported QSPI CR WLEN 128 bits is not supported for tda3xx platform.  <a href="group___q_s_p_i___f_l_a_s_h.html#ga6b1ca424645902d7bb1200c801bdf61c">More...</a><br /></td></tr>
<tr class="separator:ga6b1ca424645902d7bb1200c801bdf61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd607837dc2c1a1be8b8f3de8ab001d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gaadd607837dc2c1a1be8b8f3de8ab001d">qspi_CR_FLEN_e</a> { <br />
&#160;&#160;<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ggaadd607837dc2c1a1be8b8f3de8ab001dafb2568f717e2c851a31c7a3ed962cd52">QSPI_CR_FLEN_1_WORD</a> = 0x0, 
<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ggaadd607837dc2c1a1be8b8f3de8ab001da24efcfea03b6d77e4e2efe25fb146c81">QSPI_CR_FLEN_2_WORDS</a>, 
<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ggaadd607837dc2c1a1be8b8f3de8ab001da5a6f418ab194d41622e37f62aff71ca5">QSPI_CR_FLEN_3_WORDS</a>, 
<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ggaadd607837dc2c1a1be8b8f3de8ab001da208021158f14fe5a73e05bc31e350403">QSPI_CR_FLEN_4_WORDS</a>, 
<br />
&#160;&#160;<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ggaadd607837dc2c1a1be8b8f3de8ab001dab4864eeb3660e2ec37a7fa0af1ce8a49">QSPI_CR_FLEN_5_WORDS</a>, 
<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ggaadd607837dc2c1a1be8b8f3de8ab001da2b5cd775ec0b03dec8a7e3a892dbefda">QSPI_CR_FLEN_6_WORDS</a>, 
<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ggaadd607837dc2c1a1be8b8f3de8ab001da43b95f7e7491343ac5578d18137a5da1">QSPI_CR_FLEN_7_WORDS</a>, 
<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ggaadd607837dc2c1a1be8b8f3de8ab001da0dd7f9488f8d07ed0907a63744a41c05">QSPI_CR_FLEN_8_WORDS</a>
<br />
 }</td></tr>
<tr class="memdesc:gaadd607837dc2c1a1be8b8f3de8ab001d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported QSPI CR FLEN.  <a href="group___q_s_p_i___f_l_a_s_h.html#gaadd607837dc2c1a1be8b8f3de8ab001d">More...</a><br /></td></tr>
<tr class="separator:gaadd607837dc2c1a1be8b8f3de8ab001d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab8311b6ba54723daed2be75adea9e5f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gab8311b6ba54723daed2be75adea9e5f9">QSPI_ConfMAddrSpace</a> (uint8_t MMPT_S, qspi_ChipSelect_e chipSelect)</td></tr>
<tr class="memdesc:gab8311b6ba54723daed2be75adea9e5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to configure memory mapped address for different chip select in control module.  <a href="group___q_s_p_i___f_l_a_s_h.html#gab8311b6ba54723daed2be75adea9e5f9">More...</a><br /></td></tr>
<tr class="separator:gab8311b6ba54723daed2be75adea9e5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0fa6a81c9df5dd1b8ed9ead69f07f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gab0fa6a81c9df5dd1b8ed9ead69f07f4a">QSPI_SelClockFrequency</a> (qspi_ClockFreq_e in_ClockSettings)</td></tr>
<tr class="memdesc:gab0fa6a81c9df5dd1b8ed9ead69f07f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to configure the clock frequency.  <a href="group___q_s_p_i___f_l_a_s_h.html#gab0fa6a81c9df5dd1b8ed9ead69f07f4a">More...</a><br /></td></tr>
<tr class="separator:gab0fa6a81c9df5dd1b8ed9ead69f07f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa93e0d71158f6cb4fb90f4e0a0131159"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gaa93e0d71158f6cb4fb90f4e0a0131159">QSPI_executeCmd</a> (<a class="el" href="struct_q_s_p_i___flash_cmd__t.html">QSPI_FlashCmd_t</a> flashCmd, uint32_t *data)</td></tr>
<tr class="memdesc:gaa93e0d71158f6cb4fb90f4e0a0131159"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to read or write data based on Word Length with data Buffer address incremented by 4 bytes only.  <a href="group___q_s_p_i___f_l_a_s_h.html#gaa93e0d71158f6cb4fb90f4e0a0131159">More...</a><br /></td></tr>
<tr class="separator:gaa93e0d71158f6cb4fb90f4e0a0131159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e025a6b30766f3a4f57577292ed9569"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga1e025a6b30766f3a4f57577292ed9569">QSPI_executeRdWrDataCmd</a> (<a class="el" href="struct_q_s_p_i___flash_cmd__t.html">QSPI_FlashCmd_t</a> flashCmd, uint32_t *data)</td></tr>
<tr class="memdesc:ga1e025a6b30766f3a4f57577292ed9569"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to read or write data based on Word Length with data Buffer address incremented by 1/2/4/8/16 bytes only.  <a href="group___q_s_p_i___f_l_a_s_h.html#ga1e025a6b30766f3a4f57577292ed9569">More...</a><br /></td></tr>
<tr class="separator:ga1e025a6b30766f3a4f57577292ed9569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2768432398fe7216427bb860802487"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gaff2768432398fe7216427bb860802487">QSPI_Initialize</a> (qspi_DeviceType_e DeviceType)</td></tr>
<tr class="memdesc:gaff2768432398fe7216427bb860802487"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to initialize all QSPI Flash modes except custom Flash Mode.  <a href="group___q_s_p_i___f_l_a_s_h.html#gaff2768432398fe7216427bb860802487">More...</a><br /></td></tr>
<tr class="separator:gaff2768432398fe7216427bb860802487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f48a25b09b8e74bd80dc8daf781beaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga6f48a25b09b8e74bd80dc8daf781beaa">QSPI_ConfigFlashDevInfo</a> (qspi_DeviceType_e flashType, const <a class="el" href="struct_q_s_p_i___flash_dev_info__t.html">QSPI_FlashDevInfo_t</a> *flashDevInfo)</td></tr>
<tr class="memdesc:ga6f48a25b09b8e74bd80dc8daf781beaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to configure the clock frequency.  <a href="group___q_s_p_i___f_l_a_s_h.html#ga6f48a25b09b8e74bd80dc8daf781beaa">More...</a><br /></td></tr>
<tr class="separator:ga6f48a25b09b8e74bd80dc8daf781beaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5547d85d7226cb203cdfe3d0c8f8d18"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gac5547d85d7226cb203cdfe3d0c8f8d18">QSPI_ReadSectors</a> (void *dstAddr, uint32_t srcOffsetAddr, uint32_t length)</td></tr>
<tr class="memdesc:gac5547d85d7226cb203cdfe3d0c8f8d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Api to reads one or several sectors from the QSPI Memory described in the Device Descriptor.  <a href="group___q_s_p_i___f_l_a_s_h.html#gac5547d85d7226cb203cdfe3d0c8f8d18">More...</a><br /></td></tr>
<tr class="separator:gac5547d85d7226cb203cdfe3d0c8f8d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17d880967f447e0d682bfa60a0b06764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga17d880967f447e0d682bfa60a0b06764">QSPI_ReadSectors_edma</a> (void *dstAddr, uint32_t srcOffsetAddr, uint32_t length, uint32_t edma_ch_num)</td></tr>
<tr class="memdesc:ga17d880967f447e0d682bfa60a0b06764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Api to reads one or several sectors from the QSPI Memory described in the Device Descriptor using EDMA.  <a href="group___q_s_p_i___f_l_a_s_h.html#ga17d880967f447e0d682bfa60a0b06764">More...</a><br /></td></tr>
<tr class="separator:ga17d880967f447e0d682bfa60a0b06764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7133bc633cd191d1078b6a7bc23aaa"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gaff7133bc633cd191d1078b6a7bc23aaa">QSPI_Configure</a> (uint32_t ConfigId, uint32_t ConfigValue)</td></tr>
<tr class="memdesc:gaff7133bc633cd191d1078b6a7bc23aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to configure the QSPI Flash.  <a href="group___q_s_p_i___f_l_a_s_h.html#gaff7133bc633cd191d1078b6a7bc23aaa">More...</a><br /></td></tr>
<tr class="separator:gaff7133bc633cd191d1078b6a7bc23aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6208809ec9d7bf7dd1c83d9488bb092"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gae6208809ec9d7bf7dd1c83d9488bb092">QSPI_WriteSectors</a> (uint32_t dstOffsetAddr, uint32_t srcAddr, uint32_t length)</td></tr>
<tr class="memdesc:gae6208809ec9d7bf7dd1c83d9488bb092"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to Writes one or several sectors to the QSPI Memory blocking mode.  <a href="group___q_s_p_i___f_l_a_s_h.html#gae6208809ec9d7bf7dd1c83d9488bb092">More...</a><br /></td></tr>
<tr class="separator:gae6208809ec9d7bf7dd1c83d9488bb092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52584c84bb1bcbf4be63d29c018e1e3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gab52584c84bb1bcbf4be63d29c018e1e3">QSPI_WriteSectorsNonBlocking</a> (uint32_t dstOffsetAddr, uint32_t srcAddr, uint32_t length)</td></tr>
<tr class="memdesc:gab52584c84bb1bcbf4be63d29c018e1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to Writes one or several sectors to the QSPI Memory in non blocking mode flash status should be checked before sending next command Bit 0 of Flash status should be 0 indicating flash is not busy Ex: while ((<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gae66b02fad19f150e2588e00e1fc29dd0" title="API to check flash status. ">QSPI_FlashStatus()</a> &amp; 0x01)) ; Note: write in memory map mode is not supported by driver. This is because Most of the flashes require write enable (WE) command to be sent before sending the write command. This puts a restriction on mem mapped write that after every word write, switch to cfg mode and send WE command. This is in effecient and also the IP was not designed for the mem mapped write operations.  <a href="group___q_s_p_i___f_l_a_s_h.html#gab52584c84bb1bcbf4be63d29c018e1e3">More...</a><br /></td></tr>
<tr class="separator:gab52584c84bb1bcbf4be63d29c018e1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga859ea61930c437ef90a52bcb1c4a3099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga859ea61930c437ef90a52bcb1c4a3099">QSPI_WriteCfgMode</a> (uint32_t dstOffsetAddr, uint32_t srcAddr, uint32_t length)</td></tr>
<tr class="memdesc:ga859ea61930c437ef90a52bcb1c4a3099"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to write data on flash moemory.  <a href="group___q_s_p_i___f_l_a_s_h.html#ga859ea61930c437ef90a52bcb1c4a3099">More...</a><br /></td></tr>
<tr class="separator:ga859ea61930c437ef90a52bcb1c4a3099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc06f92199f61c765c1fe238103d3651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gafc06f92199f61c765c1fe238103d3651">QSPI_WriteCfgModeNonBlocking</a> (uint32_t dstOffsetAddr, uint32_t srcAddr, uint32_t length)</td></tr>
<tr class="memdesc:gafc06f92199f61c765c1fe238103d3651"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to write data on flash moemory.  <a href="group___q_s_p_i___f_l_a_s_h.html#gafc06f92199f61c765c1fe238103d3651">More...</a><br /></td></tr>
<tr class="separator:gafc06f92199f61c765c1fe238103d3651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1ef643528fe4fd43977a177ae0da2f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gadf1ef643528fe4fd43977a177ae0da2f">QSPI_GetDeviceId</a> (void)</td></tr>
<tr class="memdesc:gadf1ef643528fe4fd43977a177ae0da2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get device ID.  <a href="group___q_s_p_i___f_l_a_s_h.html#gadf1ef643528fe4fd43977a177ae0da2f">More...</a><br /></td></tr>
<tr class="separator:gadf1ef643528fe4fd43977a177ae0da2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7cd77177a9a9659f7a60a8bcbf7340c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gac7cd77177a9a9659f7a60a8bcbf7340c">QSPI_GetDeviceIdExtended</a> (uint32_t numSpiWords, uint32_t *data)</td></tr>
<tr class="memdesc:gac7cd77177a9a9659f7a60a8bcbf7340c"><td class="mdescLeft">&#160;</td><td class="mdescRight">QSPI Get Device Id.  <a href="group___q_s_p_i___f_l_a_s_h.html#gac7cd77177a9a9659f7a60a8bcbf7340c">More...</a><br /></td></tr>
<tr class="separator:gac7cd77177a9a9659f7a60a8bcbf7340c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697d7f6d0d4a1bac4d7c1ccfe0bef75c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga697d7f6d0d4a1bac4d7c1ccfe0bef75c">QSPI_ReadCfgMode</a> (uint32_t dstAddr, uint32_t srcOffsetAddr, uint32_t length)</td></tr>
<tr class="memdesc:ga697d7f6d0d4a1bac4d7c1ccfe0bef75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to read data from flash moemory.  <a href="group___q_s_p_i___f_l_a_s_h.html#ga697d7f6d0d4a1bac4d7c1ccfe0bef75c">More...</a><br /></td></tr>
<tr class="separator:ga697d7f6d0d4a1bac4d7c1ccfe0bef75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff130c4f046f530a9be1ff008e3105dc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gaff130c4f046f530a9be1ff008e3105dc">QSPIFlash_ReadMID</a> (void)</td></tr>
<tr class="memdesc:gaff130c4f046f530a9be1ff008e3105dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to read MID.  <a href="group___q_s_p_i___f_l_a_s_h.html#gaff130c4f046f530a9be1ff008e3105dc">More...</a><br /></td></tr>
<tr class="separator:gaff130c4f046f530a9be1ff008e3105dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae66b02fad19f150e2588e00e1fc29dd0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gae66b02fad19f150e2588e00e1fc29dd0">QSPI_FlashStatus</a> (void)</td></tr>
<tr class="memdesc:gae66b02fad19f150e2588e00e1fc29dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to check flash status.  <a href="group___q_s_p_i___f_l_a_s_h.html#gae66b02fad19f150e2588e00e1fc29dd0">More...</a><br /></td></tr>
<tr class="separator:gae66b02fad19f150e2588e00e1fc29dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a5cf1997c3e0ac3d8f4d2133f71af6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a5cf1997c3e0ac3d8f4d2133f71af6b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga8a5cf1997c3e0ac3d8f4d2133f71af6b">QSPI_WriteEnable</a> (void)</td></tr>
<tr class="memdesc:ga8a5cf1997c3e0ac3d8f4d2133f71af6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to enable flash for writing data. <br /></td></tr>
<tr class="separator:ga8a5cf1997c3e0ac3d8f4d2133f71af6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab0f2fb4835088d55254945676ea7f18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaab0f2fb4835088d55254945676ea7f18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gaab0f2fb4835088d55254945676ea7f18">QSPI_QuadEnable</a> (void)</td></tr>
<tr class="memdesc:gaab0f2fb4835088d55254945676ea7f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to Enable Quad. <br /></td></tr>
<tr class="separator:gaab0f2fb4835088d55254945676ea7f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga279cadb142bc4064fceabb404d3434f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga279cadb142bc4064fceabb404d3434f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga279cadb142bc4064fceabb404d3434f6">QSPI_QuadEnableNonBlocking</a> (void)</td></tr>
<tr class="memdesc:ga279cadb142bc4064fceabb404d3434f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to Enable Quad in non blocking mode flash status should be checked before sending next command Bit 0 of Flash status should be 0 indicating flash is not busy Ex: while ((<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gae66b02fad19f150e2588e00e1fc29dd0" title="API to check flash status. ">QSPI_FlashStatus()</a> &amp; 0x01)) ;. <br /></td></tr>
<tr class="separator:ga279cadb142bc4064fceabb404d3434f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60cd9c7d33e148051e6e0011c545651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gaf60cd9c7d33e148051e6e0011c545651">QSPI_FlashSubSectorErase</a> (uint32_t offsetAddr)</td></tr>
<tr class="memdesc:gaf60cd9c7d33e148051e6e0011c545651"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to erase sub sector in flash memory.  <a href="group___q_s_p_i___f_l_a_s_h.html#gaf60cd9c7d33e148051e6e0011c545651">More...</a><br /></td></tr>
<tr class="separator:gaf60cd9c7d33e148051e6e0011c545651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f00f9ef0411301003abd106ba8da7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gac6f00f9ef0411301003abd106ba8da7c">QSPI_FlashSubSectorEraseNonBlocking</a> (uint32_t offsetAddr)</td></tr>
<tr class="memdesc:gac6f00f9ef0411301003abd106ba8da7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to erase sub sector in flash memory in non blocking mode flash status should be checked before sending next command Bit 0 of Flash status should be 0 indicating flash is not busy Ex: while ((<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gae66b02fad19f150e2588e00e1fc29dd0" title="API to check flash status. ">QSPI_FlashStatus()</a> &amp; 0x01)) ; In some flashes (Ex: Spansion flashes used in TI EVMs) the sectors are organized as a hybrid combination of 4-kB and 64-kB sectors, and when the sub sector erase is executed on 64-kB sector the API returns with success without erasing. Since this is flash dpecific driver will not check for this. Application calling this API should make sure that this API is called only for the supported sectors.  <a href="group___q_s_p_i___f_l_a_s_h.html#gac6f00f9ef0411301003abd106ba8da7c">More...</a><br /></td></tr>
<tr class="separator:gac6f00f9ef0411301003abd106ba8da7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga602b4e4e686998ce28a37b8839fff354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga602b4e4e686998ce28a37b8839fff354">QSPI_FlashBlockErase</a> (uint32_t blkNo)</td></tr>
<tr class="memdesc:ga602b4e4e686998ce28a37b8839fff354"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to erase a block in flash memory.  <a href="group___q_s_p_i___f_l_a_s_h.html#ga602b4e4e686998ce28a37b8839fff354">More...</a><br /></td></tr>
<tr class="separator:ga602b4e4e686998ce28a37b8839fff354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fd99416f2d6f733bf513d2ccca8c65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gac6fd99416f2d6f733bf513d2ccca8c65">QSPI_FlashBlockEraseNonBlocking</a> (uint32_t blkNo)</td></tr>
<tr class="memdesc:gac6fd99416f2d6f733bf513d2ccca8c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to erase a block in flash memory flash status should be checked before sending next command Bit 0 of Flash status should be 0 indicating flash is not busy Ex: while ((<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gae66b02fad19f150e2588e00e1fc29dd0" title="API to check flash status. ">QSPI_FlashStatus()</a> &amp; 0x01)) ;.  <a href="group___q_s_p_i___f_l_a_s_h.html#gac6fd99416f2d6f733bf513d2ccca8c65">More...</a><br /></td></tr>
<tr class="separator:gac6fd99416f2d6f733bf513d2ccca8c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66067cd8036dfc67e61b7aa61aa0c7ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66067cd8036dfc67e61b7aa61aa0c7ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga66067cd8036dfc67e61b7aa61aa0c7ca">QSPI_FlashFullErase</a> (void)</td></tr>
<tr class="memdesc:ga66067cd8036dfc67e61b7aa61aa0c7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">API Erase full flash. <br /></td></tr>
<tr class="separator:ga66067cd8036dfc67e61b7aa61aa0c7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa29ec936aff178df6bebe69e35de3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3aa29ec936aff178df6bebe69e35de3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga3aa29ec936aff178df6bebe69e35de3a">QSPI_FlashFullEraseNonBlocking</a> (void)</td></tr>
<tr class="memdesc:ga3aa29ec936aff178df6bebe69e35de3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">API Erase full flash in non blocking mode flash status should be checked before sending next command Bit 0 of Flash status should be 0 indicating flash is not busy Ex: while ((<a class="el" href="group___q_s_p_i___f_l_a_s_h.html#gae66b02fad19f150e2588e00e1fc29dd0" title="API to check flash status. ">QSPI_FlashStatus()</a> &amp; 0x01)) ;. <br /></td></tr>
<tr class="separator:ga3aa29ec936aff178df6bebe69e35de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25ea45cc8aa1be03d5a6ad6fe77f32da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga25ea45cc8aa1be03d5a6ad6fe77f32da">QSPI_seek</a> (uint32_t *srcAddr, uint32_t location)</td></tr>
<tr class="memdesc:ga25ea45cc8aa1be03d5a6ad6fe77f32da"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to seach for available input address.  <a href="group___q_s_p_i___f_l_a_s_h.html#ga25ea45cc8aa1be03d5a6ad6fe77f32da">More...</a><br /></td></tr>
<tr class="separator:ga25ea45cc8aa1be03d5a6ad6fe77f32da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3586616baf418aaedeccb85c6c845c8f"><td class="memItemLeft" align="right" valign="top">qspi_DeviceType_e&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga3586616baf418aaedeccb85c6c845c8f">QSPI_getFlashType</a> (qspi_DeviceType_e inDeviceType)</td></tr>
<tr class="memdesc:ga3586616baf418aaedeccb85c6c845c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get flash type.  <a href="group___q_s_p_i___f_l_a_s_h.html#ga3586616baf418aaedeccb85c6c845c8f">More...</a><br /></td></tr>
<tr class="separator:ga3586616baf418aaedeccb85c6c845c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1146ec13a25a43521cd142ac570f5582"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___q_s_p_i___f_l_a_s_h.html#ga1146ec13a25a43521cd142ac570f5582">QSPI_DeInitialize</a> (void)</td></tr>
<tr class="memdesc:ga1146ec13a25a43521cd142ac570f5582"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to de inititalize the flash parameters.  <a href="group___q_s_p_i___f_l_a_s_h.html#ga1146ec13a25a43521cd142ac570f5582">More...</a><br /></td></tr>
<tr class="separator:ga1146ec13a25a43521cd142ac570f5582"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains the interfaces present in the QSPI Flash Library. This also contains some related macros, structures and enums. </p>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2019, Texas Instruments Incorporated</small>
</body>
</html>
